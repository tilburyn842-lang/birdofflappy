<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bird of Flappy</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
        }
        
        @font-face {
            font-family: 'PixelFont';
            src: local('Courier New'), local('monospace');
        }
        
        * {
            font-family: 'PixelFont', 'Courier New', monospace !important;
        }
        
        #gameCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        #score {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 48px;
            color: white;
            z-index: 10;
            font-weight: bold;
            text-align: center;
            text-shadow: 0 0 10px #FFD700;
        }
        
        #coins {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 10;
        }
        
        .coins-display {
            display: flex;
            align-items: center;
            background: linear-gradient(135deg, #2c2c2c, #1a1a1a);
            border: 3px solid #FFD700;
            border-radius: 10px;
            padding: 8px 12px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.6);
        }
        
        .coin-icon-game {
            width: 32px;
            height: 32px;
            background: radial-gradient(circle at 30% 30%, #FFD700, #FFA500);
            border-radius: 50%;
            border: 2px solid #FF8C00;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            color: #FF8C00;
        }
        
        .coin-count {
            font-size: 24px;
            font-weight: bold;
            color: #FFD700;
            margin-left: 6px;
        }
        
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        #startScreen.active {
            opacity: 1;
            pointer-events: all;
        }
        
        #startScreen h1 {
            font-size: 60px;
            margin-bottom: 15px;
            color: #FFD700;
            letter-spacing: 5px;
            animation: bounce 2s infinite;
            text-align: center;
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-15px); }
        }
        
        #startScreen p {
            font-size: 20px;
            color: white;
            margin-bottom: 5px;
        }
        
        .stats-display {
            display: flex;
            gap: 30px;
            margin: 15px 0;
            font-size: 24px;
            color: white;
        }
        
        .stat-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .button-row {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        
        .play-button {
            background: linear-gradient(135deg, #FF6B6B, #FF3838);
            color: white;
            border: 4px solid #FFD700;
            padding: 15px 60px;
            font-size: 32px;
            margin: 15px;
            cursor: pointer;
            border-radius: 15px;
            font-weight: bold;
            box-shadow: 0 10px 25px rgba(0,0,0,0.6);
            transition: all 0.3s;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .play-button:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 15px 30px rgba(0,0,0,0.7);
        }
        
        .play-button:active {
            transform: translateY(-2px) scale(1.02);
        }
        
        .fade-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            z-index: 250;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.6s ease;
        }
        
        .fade-overlay.active {
            opacity: 1;
        }
        
        #shop, #inventory, #index, #challenges, #achievements, #upgrades {
            position: fixed;
            top: 0;
            right: -400px;
            width: 380px;
            height: 100vh;
            background: rgba(0,0,0,0.97);
            padding: 20px;
            overflow-y: auto;
            z-index: 200;
            transition: right 0.3s ease;
            border-left: 3px solid #5cb85c;
        }
        
        #shop.open, #inventory.open, #index.open, #challenges.open, #achievements.open, #upgrades.open {
            right: 0;
        }
        
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 150;
            display: none;
        }
        
        .menu-overlay.active {
            display: block;
        }
        
        .menu-button {
            background: linear-gradient(135deg, #4ECDC4, #44A08D);
            color: white;
            border: 3px solid #FFD700;
            padding: 15px;
            font-size: 18px;
            margin: 0;
            cursor: pointer;
            border-radius: 15px;
            font-weight: bold;
            width: 160px;
            height: 160px;
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.5);
            transition: all 0.3s;
        }
        
        .menu-button:hover {
            transform: translateY(-5px) scale(1.03);
            box-shadow: 0 12px 25px rgba(0,0,0,0.6);
            background: linear-gradient(135deg, #5EDDD4, #54B09D);
        }
        
        .menu-button:active {
            transform: translateY(-2px) scale(1.01);
        }
        
        .shop-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
            margin: 15px 0;
        }
        
        .shop-section {
            margin: 20px 0;
        }
        
        .section-title {
            font-size: 24px;
            color: #FFD700;
            margin-bottom: 15px;
            border-bottom: 2px solid #FFD700;
            padding-bottom: 5px;
        }
        
        .item-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
            border: 2px solid #5cb85c;
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .item-card:hover {
            background: linear-gradient(135deg, rgba(255,255,255,0.2), rgba(255,255,255,0.1));
            transform: translateX(5px);
            border-color: #FFD700;
        }
        
        .item-card.equipped {
            border-color: #FFD700;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.3), rgba(255, 215, 0, 0.1));
        }
        
        .item-card.locked {
            opacity: 0.6;
        }
        
        .item-preview {
            width: 60px;
            height: 60px;
            border: 2px solid #000;
            border-radius: 8px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
        }
        
        .item-info {
            flex: 1;
        }
        
        .item-name {
            font-size: 18px;
            margin: 0 0 5px 0;
            color: white;
            font-weight: bold;
        }
        
        .item-description {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 5px;
        }
        
        .item-price {
            font-size: 16px;
            color: #FFD700;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .back-btn {
            position: static;
            background: linear-gradient(135deg, #d9534f, #c9302c);
            border-color: #FFD700;
            padding: 10px 20px;
            font-size: 16px;
            width: 100%;
            margin-bottom: 15px;
            height: auto;
        }
        
        .hidden {
            display: none !important;
        }
        
        .shop-currency {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            padding: 10px;
            background: rgba(255,215,0,0.1);
            border-radius: 10px;
            border: 2px solid #FFD700;
        }
        
        .shop-coin-icon {
            width: 40px;
            height: 40px;
            background: radial-gradient(circle at 30% 30%, #FFD700, #FFA500);
            border-radius: 50%;
            border: 2px solid #FF8C00;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 20px;
            color: #FF8C00;
        }
        
        .shop-coin-count {
            font-size: 28px;
            font-weight: bold;
            color: #FFD700;
        }
        
        .loading {
            color: white;
            text-align: center;
            padding: 20px;
            font-size: 16px;
        }
        
        .error {
            color: #ff6b6b;
            text-align: center;
            padding: 20px;
            font-size: 16px;
        }
        
        /* Crate Shop Styles */
        .crate-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 15px 0;
        }
        
        .crate-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
            border: 3px solid;
            padding: 15px;
            border-radius: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        .crate-card:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 20px rgba(255, 215, 0, 0.3);
        }
        
        .crate-icon {
            font-size: 60px;
            animation: float 3s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        .crate-name {
            font-size: 18px;
            color: white;
            font-weight: bold;
        }
        
        .crate-price {
            font-size: 20px;
            color: #FFD700;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }
        
        .crate-chance {
            font-size: 12px;
            color: #aaa;
        }
        
        /* Crate Opening Animation */
        .crate-opening {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 500;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .crate-opening.active {
            display: flex;
        }
        
        .crate-display {
            font-size: 120px;
            margin-bottom: 30px;
            animation: crateBounce 1s infinite;
        }
        
        @keyframes crateBounce {
            0%, 100% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.1) rotate(5deg); }
            75% { transform: scale(1.1) rotate(-5deg); }
        }
        
        .roll-display {
            font-size: 32px;
            color: white;
            margin-bottom: 30px;
            text-align: center;
            min-height: 40px;
        }
        
        .result-display {
            font-size: 48px;
            color: #FFD700;
            margin: 30px 0;
            text-align: center;
            animation: resultPulse 0.5s infinite;
        }
        
        @keyframes resultPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .crate-continue-btn {
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
            color: white;
            border: 3px solid #FFD700;
            padding: 15px 40px;
            font-size: 24px;
            cursor: pointer;
            border-radius: 10px;
            font-weight: bold;
            margin-top: 20px;
        }
        
        /* Inventory Styles */
        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin: 15px 0;
        }
        
        .skin-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
            border: 2px solid;
            padding: 12px;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .skin-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .skin-card.equipped {
            border-color: #FFD700 !important;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.3), rgba(255, 215, 0, 0.1));
        }
        
        .skin-card.secret {
            border: 2px solid #FF0000;
            background: linear-gradient(135deg, rgba(255, 0, 0, 0.2), rgba(255, 0, 0, 0.1));
        }
        
        .skin-emoji {
            font-size: 40px;
            margin-bottom: 8px;
        }
        
        .skin-name {
            font-size: 14px;
            color: white;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .skin-actions {
            display: flex;
            gap: 5px;
            margin-top: 8px;
        }
        
        .skin-action-btn {
            flex: 1;
            padding: 5px;
            border-radius: 5px;
            border: none;
            font-size: 12px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .equip-btn {
            background: #4CAF50;
            color: white;
        }
        
        .sell-btn {
            background: #ff6b6b;
            color: white;
        }
        
        .sell-price {
            font-size: 12px;
            color: #FFD700;
            margin-top: 5px;
        }
        
        /* Message Queue System */
        .message-queue {
            position: fixed;
            top: 150px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            pointer-events: none;
        }
        
        .message-item {
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 12px 24px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            border: 2px solid #FFD700;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.3s ease;
            text-align: center;
            max-width: 300px;
        }
        
        .message-item.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .message-item.achievement {
            background: rgba(106, 13, 173, 0.9);
            border-color: #8A2BE2;
        }
        
        .message-item.coin {
            background: rgba(255, 215, 0, 0.9);
            color: #000;
            border-color: #FF8C00;
        }
        
        .message-item.secret {
            background: rgba(255, 0, 0, 0.9);
            border-color: #FF0000;
            animation: secretGlow 0.5s infinite;
        }
        
        @keyframes secretGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 0, 0, 0.7); }
            50% { box-shadow: 0 0 40px rgba(255, 0, 0, 1); }
        }
        
        /* Index Styles */
        .index-filters {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .filter-btn {
            background: rgba(255,255,255,0.1);
            border: 2px solid #5cb85c;
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .filter-btn.active {
            background: #5cb85c;
            border-color: #4CAF50;
        }
        
        .filter-btn:hover {
            transform: translateY(-2px);
        }
        
        .index-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 15px 0;
        }
        
        .index-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
            border: 2px solid;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-size: 12px;
        }
        
        .index-card.owned {
            border-color: #4CAF50;
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.3), rgba(76, 175, 80, 0.1));
        }
        
        .index-card.secret {
            border-color: #FF0000;
            background: linear-gradient(135deg, rgba(255, 0, 0, 0.3), rgba(255, 0, 0, 0.1));
        }
        
        .index-emoji {
            font-size: 30px;
            margin-bottom: 5px;
        }
        
        .index-name {
            color: white;
            margin-bottom: 3px;
            font-weight: bold;
        }
        
        .index-rarity {
            font-size: 10px;
            margin-bottom: 2px;
        }
        
        .index-stats {
            font-size: 9px;
            color: #aaa;
        }
        
        /* Secret Ability Display */
        .ability-display {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            color: #FF0000;
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 20px;
            font-weight: bold;
            z-index: 100;
            border: 2px solid #FF0000;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.7);
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .ability-display.show {
            opacity: 1;
        }
        
        /* Challenge styles */
        .challenge-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            margin: 15px 0;
        }
        
        .challenge-card {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.1), rgba(76, 175, 80, 0.05));
            border: 2px solid #4CAF50;
            padding: 15px;
            border-radius: 10px;
            transition: all 0.3s;
        }
        
        .challenge-card.completed {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.3), rgba(255, 215, 0, 0.1));
            border-color: #FFD700;
        }
        
        .challenge-title {
            font-size: 18px;
            margin: 0 0 8px 0;
            color: white;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .challenge-description {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 10px;
        }
        
        .challenge-reward {
            font-size: 16px;
            color: #FFD700;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .challenge-progress {
            margin-top: 8px;
            background: rgba(255,255,255,0.1);
            height: 6px;
            border-radius: 3px;
            overflow: hidden;
        }
        
        .challenge-progress-bar {
            height: 100%;
            background: #4CAF50;
            border-radius: 3px;
            transition: width 0.3s ease;
        }
        
        .challenge-progress-text {
            font-size: 12px;
            color: #aaa;
            text-align: right;
            margin-top: 2px;
        }
        
        .challenges-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #FFD700;
        }
        
        .daily-reset {
            font-size: 14px;
            color: #aaa;
            text-align: center;
            margin-top: 10px;
        }
        
        .challenge-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            margin-right: 10px;
        }
        
        .challenge-title-content {
            display: flex;
            align-items: center;
        }
        
        /* Achievement styles */
        .achievement-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        
        .achievement-card {
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.1), rgba(75, 0, 130, 0.05));
            border: 2px solid #8A2BE2;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            transition: all 0.3s;
        }
        
        .achievement-card.completed {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.3), rgba(255, 215, 0, 0.1));
            border-color: #FFD700;
        }
        
        .achievement-icon {
            font-size: 40px;
            margin-bottom: 10px;
        }
        
        .achievement-name {
            font-size: 16px;
            color: white;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .achievement-desc {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 8px;
        }
        
        .achievement-reward {
            font-size: 14px;
            color: #FFD700;
            font-weight: bold;
        }
        
        /* Daily Login styles */
        .login-calendar {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 8px;
            margin: 15px 0;
        }
        
        .login-day {
            background: rgba(255,255,255,0.1);
            border: 2px solid #5cb85c;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            position: relative;
            min-height: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .login-day.claimed {
            background: rgba(76, 175, 80, 0.3);
            border-color: #4CAF50;
        }
        
        .login-day.today {
            background: rgba(255, 215, 0, 0.3);
            border-color: #FFD700;
            animation: pulse 2s infinite;
        }
        
        .login-reward {
            font-size: 12px;
            color: #FFD700;
            font-weight: bold;
            margin-top: 5px;
        }
        
        .login-streak {
            font-size: 18px;
            color: #FFD700;
            text-align: center;
            margin: 10px 0;
        }
        
        /* Secret Effect Styles */
        .secret-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 900;
            display: none;
        }
        
        .secret-effect.active {
            display: block;
        }
        
        .secret-particle {
            position: absolute;
            pointer-events: none;
            font-size: 24px;
            animation: secretFloat 2s linear forwards;
        }
        
        @keyframes secretFloat {
            0% {
                transform: translateY(100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(-100px) rotate(360deg);
                opacity: 0;
            }
        }
        
        /* Achievement Progress Bar */
        .achievement-progress {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            text-align: center;
        }
        
        .progress-bar {
            height: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 5px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            border-radius: 10px;
            transition: width 0.3s ease;
        }
        
        /* Search Bar */
        .search-bar {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            background: rgba(255,255,255,0.1);
            border: 2px solid #5cb85c;
            border-radius: 5px;
            color: white;
            font-size: 16px;
        }
        
        .search-bar::placeholder {
            color: #aaa;
        }
        
        /* Upgrade Styles */
        .upgrade-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            margin: 15px 0;
        }
        
        .upgrade-card {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.1), rgba(76, 175, 80, 0.05));
            border: 2px solid #5cb85c;
            padding: 15px;
            border-radius: 10px;
            transition: all 0.3s;
        }
        
        .upgrade-card.maxed {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.3), rgba(255, 215, 0, 0.1));
            border-color: #FFD700;
        }
        
        .upgrade-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .upgrade-title {
            font-size: 18px;
            color: white;
            font-weight: bold;
        }
        
        .upgrade-level {
            font-size: 16px;
            color: #FFD700;
            font-weight: bold;
        }
        
        .upgrade-description {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 10px;
        }
        
        .upgrade-stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 14px;
            color: white;
        }
        
        .upgrade-cost {
            font-size: 16px;
            color: #FFD700;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
            margin-bottom: 10px;
        }
        
        .upgrade-btn {
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
            color: white;
            border: 2px solid #FFD700;
            padding: 10px;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
            transition: all 0.3s;
        }
        
        .upgrade-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #5CBF60, #3C8D42);
            transform: translateY(-2px);
        }
        
        .upgrade-btn:disabled {
            background: #666;
            color: #999;
            cursor: not-allowed;
            border-color: #666;
        }
        
        .upgrade-progress {
            margin-top: 8px;
            background: rgba(255,255,255,0.1);
            height: 6px;
            border-radius: 3px;
            overflow: hidden;
        }
        
        .upgrade-progress-bar {
            height: 100%;
            background: #4CAF50;
            border-radius: 3px;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="score">0</div>
    <div id="coins" class="hidden">
        <div class="coins-display">
            <div class="coin-icon-game">GU</div>
            <div class="coin-count" id="coinCount">0</div>
        </div>
    </div>
    
    <div class="message-queue" id="messageQueue"></div>
    <div class="ability-display" id="abilityDisplay"></div>
    <div class="secret-effect" id="secretEffect"></div>
    
    <div class="fade-overlay" id="fadeOverlay"></div>
    <div class="menu-overlay" id="menuOverlay" onclick="closeAllMenus()"></div>
    <div class="celebration" id="celebration"></div>
    
    <!-- Crate Opening Animation -->
    <div class="crate-opening" id="crateOpening">
        <div class="crate-display" id="crateDisplay">üì¶</div>
        <div class="roll-display" id="rollDisplay">Opening crate...</div>
        <div class="result-display" id="resultDisplay"></div>
        <button class="crate-continue-btn" onclick="closeCrateOpening()">CONTINUE</button>
    </div>
    
    <div id="startScreen" class="active">
        <h1>BIRD OF FLAPPY</h1>
        <p>Click or Press SPACE to Start</p>
        
        <div class="stats-display">
            <div class="stat-item">
                <span style="font-size: 24px;">üèÜ</span>
                <span>High Score: <span id="menuHighScore">0</span></span>
            </div>
            <div class="stat-item">
                <div class="coin-icon-game" style="width: 30px; height: 30px; font-size: 12px;">GU</div>
                <span><span id="menuCoins">0</span> GU</span>
            </div>
        </div>
        
        <button class="play-button" onclick="startGameFromMenu()">‚ñ∂ PLAY</button>
        
        <div class="button-row">
            <button class="menu-button" onclick="toggleShop()">
                <span style="font-size: 48px;">üì¶</span>
                <span>CRATE SHOP</span>
            </button>
            <button class="menu-button" onclick="toggleInventory()">
                <span style="font-size: 48px;">üéí</span>
                <span>INVENTORY</span>
            </button>
            <button class="menu-button" onclick="toggleIndex()">
                <span style="font-size: 48px;">üìñ</span>
                <span>SKIN INDEX</span>
            </button>
        </div>
        
        <div class="button-row">
            <button class="menu-button" onclick="toggleAchievements()">
                <span style="font-size: 48px;">üèÖ</span>
                <span>ACHIEVEMENTS</span>
            </button>
            <button class="menu-button" onclick="toggleChallenges()">
                <span style="font-size: 48px;">üéØ</span>
                <span>DAILY</span>
            </button>
            <button class="menu-button" onclick="toggleUpgrades()">
                <span style="font-size: 48px;">‚ö°</span>
                <span>UPGRADES</span>
            </button>
        </div>
        
        <div class="login-streak" id="dailyLoginInfo">
            Daily Login Bonus Available!
        </div>
    </div>
    
    <!-- Crate Shop Menu -->
    <div id="shop">
        <button class="menu-button back-btn" onclick="toggleShop()">‚úñ CLOSE</button>
        <h1 style="font-size: 36px; margin-bottom: 15px; color: #FFD700; text-align: center;">CRATE SHOP</h1>
        
        <div class="shop-currency">
            <div class="shop-coin-icon">GU</div>
            <div class="shop-coin-count" id="shopCoins">0 GU</div>
        </div>
        
        <div class="shop-section">
            <div class="section-title">üì¶ CRATES</div>
            <div class="crate-grid" id="crateGrid">
                <div class="loading">Loading crates...</div>
            </div>
        </div>
    </div>
    
    <!-- Inventory Menu -->
    <div id="inventory">
        <button class="menu-button back-btn" onclick="toggleInventory()">‚úñ CLOSE</button>
        <h1 style="font-size: 36px; margin-bottom: 15px; color: #FFD700; text-align: center;">INVENTORY</h1>
        
        <div class="shop-currency">
            <div class="shop-coin-icon">GU</div>
            <div class="shop-coin-count" id="inventoryCoins">0 GU</div>
        </div>
        
        <div style="text-align: center; margin-bottom: 15px; color: #FFD700;">
            Owned: <span id="ownedSkinsCount">0</span>/<span id="totalSkinsCount">0</span> skins
        </div>
        
        <div class="inventory-grid" id="inventoryGrid">
            <div class="loading">Loading inventory...</div>
        </div>
    </div>
    
    <!-- Skin Index Menu -->
    <div id="index">
        <button class="menu-button back-btn" onclick="toggleIndex()">‚úñ CLOSE</button>
        <h1 style="font-size: 36px; margin-bottom: 15px; color: #FFD700; text-align: center;">SKIN INDEX</h1>
        
        <div style="text-align: center; margin-bottom: 15px; color: #FFD700;">
            <span id="indexOwnedCount">0</span>/<span id="indexTotalCount">0</span> skins collected
        </div>
        
        <input type="text" class="search-bar" id="skinSearch" placeholder="Search skins..." oninput="searchSkins()">
        
        <div class="index-filters" id="indexFilters">
            <button class="filter-btn active" onclick="filterIndex('all')">ALL</button>
            <button class="filter-btn" onclick="filterIndex('common')">COMMON</button>
            <button class="filter-btn" onclick="filterIndex('uncommon')">UNCOMMON</button>
            <button class="filter-btn" onclick="filterIndex('rare')">RARE</button>
            <button class="filter-btn" onclick="filterIndex('epic')">EPIC</button>
            <button class="filter-btn" onclick="filterIndex('legendary')">LEGENDARY</button>
            <button class="filter-btn" onclick="filterIndex('ultra')">ULTRA</button>
            <button class="filter-btn" onclick="filterIndex('secret')">SECRET</button>
            <button class="filter-btn" onclick="filterIndex('owned')">OWNED</button>
            <button class="filter-btn" onclick="filterIndex('missing')">MISSING</button>
        </div>
        
        <div class="index-grid" id="indexGrid">
            <div class="loading">Loading index...</div>
        </div>
    </div>
    
    <!-- Challenges Menu -->
    <div id="challenges">
        <button class="menu-button back-btn" onclick="toggleChallenges()">‚úñ CLOSE</button>
        <h1 style="font-size: 36px; margin-bottom: 15px; color: #FFD700; text-align: center;">DAILY CHALLENGES</h1>
        
        <div class="challenges-header">
            <div style="font-size: 18px; color: #FFD700;">Complete challenges for rewards!</div>
        </div>
        
        <div class="daily-reset" id="dailyResetTimer">Resets in: 24h 00m</div>
        
        <div class="challenge-grid" id="challengeGrid">
            <div class="loading">Loading daily challenges...</div>
        </div>
    </div>
    
    <!-- Achievements Menu -->
    <div id="achievements">
        <button class="menu-button back-btn" onclick="toggleAchievements()">‚úñ CLOSE</button>
        <h1 style="font-size: 36px; margin-bottom: 15px; color: #FFD700; text-align: center;">ACHIEVEMENTS</h1>
        
        <div class="achievement-progress">
            <div style="color: #FFD700; font-size: 18px; margin-bottom: 5px;">
                Progress: <span id="achievementProgress">0/250</span>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="achievementProgressBar" style="width: 0%"></div>
            </div>
        </div>
        
        <input type="text" class="search-bar" id="achievementSearch" placeholder="Search achievements..." oninput="searchAchievements()">
        
        <div class="index-filters" id="achievementFilters">
            <button class="filter-btn active" onclick="filterAchievements('all')">ALL</button>
            <button class="filter-btn" onclick="filterAchievements('completed')">COMPLETED</button>
            <button class="filter-btn" onclick="filterAchievements('uncompleted')">UNCOMPLETED</button>
        </div>
        
        <div class="achievement-grid" id="achievementGrid">
            <div class="loading">Loading achievements...</div>
        </div>
    </div>
    
    <!-- Upgrades Menu -->
    <div id="upgrades">
        <button class="menu-button back-btn" onclick="toggleUpgrades()">‚úñ CLOSE</button>
        <h1 style="font-size: 36px; margin-bottom: 15px; color: #FFD700; text-align: center;">UPGRADES</h1>
        
        <div class="shop-currency">
            <div class="shop-coin-icon">GU</div>
            <div class="shop-coin-count" id="upgradeCoins">0 GU</div>
        </div>
        
        <div class="upgrade-grid" id="upgradeGrid">
            <div class="loading">Loading upgrades...</div>
        </div>
    </div>
    
    <!-- Daily Login Menu -->
    <div id="dailyLogin" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.95); padding: 30px; border-radius: 15px; border: 4px solid #FFD700; z-index: 300; text-align: center; max-width: 500px; width: 90%;">
        <h1 style="color: #FFD700; margin-bottom: 20px;">üéÅ DAILY LOGIN BONUS</h1>
        <div class="login-streak">üî• Streak: <span id="currentStreak">0</span> days</div>
        
        <div class="login-calendar" id="loginCalendar"></div>
        
        <div style="margin: 20px 0;">
            <div class="coin-icon-game" style="width: 60px; height: 60px; font-size: 20px; margin: 0 auto 10px;">GU</div>
            <div style="font-size: 24px; color: #FFD700; font-weight: bold;">Today's Reward: <span id="todaysReward">50</span> GU</div>
        </div>
        
        <button class="play-button" style="font-size: 24px; padding: 10px 30px;" onclick="claimDailyReward()">CLAIM REWARD!</button>
    </div>

    <script>
        // Add error logging
        window.onerror = function(msg, url, lineNo, columnNo, error) {
            console.error('Error:', msg, 'Line:', lineNo, 'Column:', columnNo, 'Error object:', error);
            return false;
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const startScreen = document.getElementById('startScreen');
        const messageQueue = document.getElementById('messageQueue');
        const abilityDisplay = document.getElementById('abilityDisplay');
        const secretEffect = document.getElementById('secretEffect');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            PIPE_WIDTH = canvas.width * 0.08;
            PIPE_GAP = canvas.height * 0.38;
            BASE_PIPE_SPEED = canvas.width * 0.003;
            GROUND_HEIGHT = canvas.height * 0.15;
            BASE_PIPE_DISTANCE = canvas.width * 0.6;
        });
        
        // ========== GAME MODIFIERS (SECRET ABILITIES) ==========
        const gameModifiers = {
            coinMultiplier: 1,
            scoreMultiplier: 1,
            pipeSpeed: 1,
            gravity: 1,
            jumpPower: 1,
            invincible: false,
            magnet: false,
            doubleCoins: false,
            
            reset() {
                this.coinMultiplier = 1;
                this.scoreMultiplier = 1;
                this.pipeSpeed = 1;
                this.gravity = 1;
                this.jumpPower = 1;
                this.invincible = false;
                this.magnet = false;
                this.doubleCoins = false;
            },
            
            updateFromSecret(secret) {
                this.reset();
                
                if (secret.abilities) {
                    if (secret.abilities.coinMultiplier) {
                        this.coinMultiplier = secret.abilities.coinMultiplier;
                    }
                    if (secret.abilities.scoreMultiplier) {
                        this.scoreMultiplier = secret.abilities.scoreMultiplier;
                    }
                    if (secret.abilities.pipeSpeed) {
                        this.pipeSpeed = secret.abilities.pipeSpeed;
                    }
                    if (secret.abilities.gravity) {
                        this.gravity = secret.abilities.gravity;
                    }
                    if (secret.abilities.jumpPower) {
                        this.jumpPower = secret.abilities.jumpPower;
                    }
                    if (secret.abilities.invincible) {
                        this.invincible = true;
                    }
                    if (secret.abilities.magnet) {
                        this.magnet = true;
                    }
                    if (secret.abilities.doubleCoins) {
                        this.doubleCoins = true;
                    }
                }
            },
            
            showAbility(secret) {
                if (secret.abilities) {
                    let abilityText = '';
                    if (secret.abilities.coinMultiplier) {
                        abilityText = `Coin Multiplier: x${secret.abilities.coinMultiplier}!`;
                    }
                    if (secret.abilities.scoreMultiplier) {
                        abilityText = `Score Multiplier: x${secret.abilities.scoreMultiplier}!`;
                    }
                    if (secret.abilities.invincible) {
                        abilityText = 'INVINCIBLE!';
                    }
                    if (secret.abilities.magnet) {
                        abilityText = 'COIN MAGNET!';
                    }
                    if (secret.abilities.doubleCoins) {
                        abilityText = 'DOUBLE COINS!';
                    }
                    
                    if (abilityText) {
                        abilityDisplay.textContent = abilityText;
                        abilityDisplay.classList.add('show');
                        
                        setTimeout(() => {
                            abilityDisplay.classList.remove('show');
                        }, 3000);
                    }
                }
            }
        };
        
        // ========== MESSAGE QUEUE SYSTEM ==========
        const messageSystem = {
            queue: [],
            isShowing: false,
            
            addMessage(text, type = 'normal', duration = 3000) {
                this.queue.push({ text, type, duration });
                if (!this.isShowing) {
                    this.showNext();
                }
            },
            
            showNext() {
                if (this.queue.length === 0) {
                    this.isShowing = false;
                    return;
                }
                
                this.isShowing = true;
                const message = this.queue.shift();
                
                const messageEl = document.createElement('div');
                messageEl.className = `message-item ${message.type}`;
                messageEl.textContent = message.text;
                
                messageQueue.appendChild(messageEl);
                
                setTimeout(() => {
                    messageEl.classList.add('show');
                }, 10);
                
                setTimeout(() => {
                    messageEl.classList.remove('show');
                    setTimeout(() => {
                        messageQueue.removeChild(messageEl);
                        this.showNext();
                    }, 300);
                }, message.duration);
            }
        };
        
        // ========== SOUND SYSTEM ==========
        const soundManager = {
            enabled: true,
            audioContext: null,
            
            init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch(e) {
                    console.log("Web Audio API not supported");
                    this.enabled = false;
                }
            },
            
            playJump() {
                if (!this.enabled) return;
                
                try {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(400 * gameModifiers.jumpPower, this.audioContext.currentTime);
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.3, this.audioContext.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.1);
                } catch(e) {}
            },
            
            playCoin() {
                if (!this.enabled) return;
                
                try {
                    const oscillator1 = this.audioContext.createOscillator();
                    const oscillator2 = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator1.connect(gainNode);
                    oscillator2.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator1.frequency.setValueAtTime(1200, this.audioContext.currentTime);
                    oscillator2.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    oscillator1.type = 'triangle';
                    oscillator2.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.4, this.audioContext.currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                    
                    oscillator1.start(this.audioContext.currentTime);
                    oscillator2.start(this.audioContext.currentTime);
                    oscillator1.stop(this.audioContext.currentTime + 0.3);
                    oscillator2.stop(this.audioContext.currentTime + 0.3);
                } catch(e) {}
            },
            
            playDeath() {
                if (!this.enabled) return;
                
                try {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(300, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(50, this.audioContext.currentTime + 0.5);
                    oscillator.type = 'sawtooth';
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.5, this.audioContext.currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.5);
                } catch(e) {}
            },
            
            playAchievement() {
                if (!this.enabled) return;
                
                try {
                    // Create achievement sound (Steam-like)
                    const times = [0, 0.1, 0.2, 0.3, 0.4, 0.5];
                    const notes = [523.25, 659.25, 783.99, 1046.50, 1318.51, 1567.98];
                    
                    times.forEach((time, i) => {
                        setTimeout(() => {
                            const oscillator = this.audioContext.createOscillator();
                            const gainNode = this.audioContext.createGain();
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(this.audioContext.destination);
                            
                            oscillator.frequency.setValueAtTime(notes[i], this.audioContext.currentTime);
                            oscillator.type = 'triangle';
                            
                            gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                            gainNode.gain.linearRampToValueAtTime(0.4, this.audioContext.currentTime + 0.05);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                            
                            oscillator.start(this.audioContext.currentTime);
                            oscillator.stop(this.audioContext.currentTime + 0.3);
                        }, time * 1000);
                    });
                } catch(e) {}
            },
            
            playButtonClick() {
                if (!this.enabled) return;
                
                try {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(300, this.audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(200, this.audioContext.currentTime + 0.05);
                    oscillator.type = 'square';
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.2, this.audioContext.currentTime + 0.02);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.1);
                } catch(e) {}
            },
            
            playCrateOpen() {
                if (!this.enabled) return;
                
                try {
                    // Open sound
                    const openOsc = this.audioContext.createOscillator();
                    const openGain = this.audioContext.createGain();
                    
                    openOsc.connect(openGain);
                    openGain.connect(this.audioContext.destination);
                    
                    openOsc.frequency.setValueAtTime(200, this.audioContext.currentTime);
                    openOsc.frequency.setValueAtTime(400, this.audioContext.currentTime + 0.1);
                    openOsc.type = 'sawtooth';
                    
                    openGain.gain.setValueAtTime(0, this.audioContext.currentTime);
                    openGain.gain.linearRampToValueAtTime(0.3, this.audioContext.currentTime + 0.05);
                    openGain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                    
                    openOsc.start(this.audioContext.currentTime);
                    openOsc.stop(this.audioContext.currentTime + 0.2);
                    
                    // Reveal sound
                    setTimeout(() => {
                        const revealOsc1 = this.audioContext.createOscillator();
                        const revealOsc2 = this.audioContext.createOscillator();
                        const revealGain = this.audioContext.createGain();
                        
                        revealOsc1.connect(revealGain);
                        revealOsc2.connect(revealGain);
                        revealGain.connect(this.audioContext.destination);
                        
                        revealOsc1.frequency.setValueAtTime(1000, this.audioContext.currentTime);
                        revealOsc2.frequency.setValueAtTime(1500, this.audioContext.currentTime);
                        revealOsc1.type = 'triangle';
                        revealOsc2.type = 'sine';
                        
                        revealGain.gain.setValueAtTime(0, this.audioContext.currentTime);
                        revealGain.gain.linearRampToValueAtTime(0.4, this.audioContext.currentTime + 0.1);
                        revealGain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                        
                        revealOsc1.start(this.audioContext.currentTime);
                        revealOsc2.start(this.audioContext.currentTime);
                        revealOsc1.stop(this.audioContext.currentTime + 0.5);
                        revealOsc2.stop(this.audioContext.currentTime + 0.5);
                    }, 200);
                } catch(e) {}
            },
            
            playPurchase() {
                if (!this.enabled) return;
                
                try {
                    const oscillator1 = this.audioContext.createOscillator();
                    const oscillator2 = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator1.connect(gainNode);
                    oscillator2.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator1.frequency.setValueAtTime(600, this.audioContext.currentTime);
                    oscillator2.frequency.setValueAtTime(900, this.audioContext.currentTime);
                    oscillator1.type = 'sine';
                    oscillator2.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.3, this.audioContext.currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                    
                    oscillator1.start(this.audioContext.currentTime);
                    oscillator2.start(this.audioContext.currentTime);
                    oscillator1.stop(this.audioContext.currentTime + 0.2);
                    oscillator2.stop(this.audioContext.currentTime + 0.2);
                } catch(e) {}
            },
            
            playSecret() {
                if (!this.enabled) return;
                
                try {
                    const times = [0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3];
                    const notes = [261.63, 329.63, 392.00, 523.25, 659.25, 783.99, 1046.50];
                    
                    times.forEach((time, i) => {
                        setTimeout(() => {
                            const oscillator = this.audioContext.createOscillator();
                            const gainNode = this.audioContext.createGain();
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(this.audioContext.destination);
                            
                            oscillator.frequency.setValueAtTime(notes[i], this.audioContext.currentTime);
                            oscillator.type = i % 2 === 0 ? 'sawtooth' : 'triangle';
                            
                            gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                            gainNode.gain.linearRampToValueAtTime(0.4, this.audioContext.currentTime + 0.05);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                            
                            oscillator.start(this.audioContext.currentTime);
                            oscillator.stop(this.audioContext.currentTime + 0.3);
                        }, time * 1000);
                    });
                } catch(e) {}
            },
            
            playPetUnlock() {
                if (!this.enabled) return;
                
                try {
                    // Steam achievement-like sound
                    const times = [0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4];
                    const notes = [523.25, 659.25, 783.99, 1046.50, 1318.51, 1567.98, 1975.53, 2093.00, 2637.02];
                    
                    times.forEach((time, i) => {
                        setTimeout(() => {
                            const oscillator = this.audioContext.createOscillator();
                            const gainNode = this.audioContext.createGain();
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(this.audioContext.destination);
                            
                            oscillator.frequency.setValueAtTime(notes[i], this.audioContext.currentTime);
                            oscillator.type = i % 3 === 0 ? 'sine' : i % 3 === 1 ? 'triangle' : 'sawtooth';
                            
                            gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                            gainNode.gain.linearRampToValueAtTime(0.5, this.audioContext.currentTime + 0.05);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);
                            
                            oscillator.start(this.audioContext.currentTime);
                            oscillator.stop(this.audioContext.currentTime + 0.4);
                        }, time * 1000);
                    });
                } catch(e) {}
            }
        };
        
        soundManager.init();
        
        // Add button click sound to all buttons
        document.addEventListener('click', function(e) {
            if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                soundManager.playButtonClick();
            }
        });
        
        // ========== PARTICLE SYSTEM ==========
        const particleSystem = {
            particles: [],
            
            createCoinSparkles(x, y, count = 10) {
                for (let i = 0; i < count; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8 - 2,
                        life: 1.0,
                        color: '#FFD700',
                        size: Math.random() * 5 + 2,
                        type: 'sparkle'
                    });
                }
            },
            
            createCelebration(count = 50) {
                for (let i = 0; i < count; i++) {
                    const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'];
                    this.particles.push({
                        x: Math.random() * canvas.width,
                        y: canvas.height,
                        vx: (Math.random() - 0.5) * 4,
                        vy: -Math.random() * 15 - 5,
                        life: 2.0,
                        color: colors[Math.floor(Math.random() * colors.length)],
                        size: Math.random() * 8 + 4,
                        type: 'celebration'
                    });
                }
            },
            
            createSecretEffect(emoji, count = 30) {
                for (let i = 0; i < count; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'secret-particle';
                    particle.textContent = emoji;
                    particle.style.left = Math.random() * 100 + 'vw';
                    particle.style.top = '100vh';
                    secretEffect.appendChild(particle);
                    
                    setTimeout(() => {
                        if (particle.parentNode === secretEffect) {
                            secretEffect.removeChild(particle);
                        }
                    }, 2000);
                }
            },
            
            update() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.3 * gameModifiers.gravity;
                    p.life -= 0.02;
                    
                    if (p.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            },
            
            draw() {
                this.particles.forEach(p => {
                    ctx.save();
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });
            }
        };
        
        // ========== SAVE DATA ==========
        const saveData = {
            coins: parseInt(localStorage.getItem('flappyCoins') || '0'),
            highScore: parseInt(localStorage.getItem('flappyHighScore') || '0'),
            currentSkin: localStorage.getItem('flappySkin') || 'common_0',
            ownedSkins: JSON.parse(localStorage.getItem('flappyOwnedSkins') || '["common_0"]'),
            playerId: localStorage.getItem('flappyPlayerId') || generatePlayerId(),
            achievements: JSON.parse(localStorage.getItem('flappyAchievements') || '{}'),
            achievementsProgress: JSON.parse(localStorage.getItem('flappyAchievementsProgress') || '{}'),
            loginStreak: parseInt(localStorage.getItem('flappyLoginStreak') || '0'),
            lastLoginDate: localStorage.getItem('flappyLastLoginDate') || '',
            dailyRewardsClaimed: JSON.parse(localStorage.getItem('flappyDailyRewardsClaimed') || '[]'),
            completedChallenges: JSON.parse(localStorage.getItem('flappyCompletedChallenges') || '{}'),
            challengeProgress: JSON.parse(localStorage.getItem('flappyChallengeProgress') || '{}'),
            lastPlayDate: localStorage.getItem('flappyLastPlayDate') || '',
            dailyChallenges: JSON.parse(localStorage.getItem('flappyDailyChallenges') || 'null'),
            totalMovingPipesPassed: parseInt(localStorage.getItem('flappyTotalMovingPipes') || '0'),
            totalGamesPlayed: parseInt(localStorage.getItem('flappyTotalGamesPlayed') || '0'),
            totalCoinsCollected: parseInt(localStorage.getItem('flappyTotalCoinsCollected') || '0'),
            totalPipesPassed: parseInt(localStorage.getItem('flappyTotalPipesPassed') || '0'),
            secretEffects: JSON.parse(localStorage.getItem('flappySecretEffects') || '{}'),
            upgrades: JSON.parse(localStorage.getItem('flappyUpgrades') || '{"coinMultiplier": 1}')
        };
        
        function generatePlayerId() {
            return 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }
        
        function saveGame() {
            localStorage.setItem('flappyCoins', saveData.coins);
            localStorage.setItem('flappyHighScore', saveData.highScore);
            localStorage.setItem('flappySkin', saveData.currentSkin);
            localStorage.setItem('flappyOwnedSkins', JSON.stringify(saveData.ownedSkins));
            localStorage.setItem('flappyPlayerId', saveData.playerId);
            localStorage.setItem('flappyAchievements', JSON.stringify(saveData.achievements));
            localStorage.setItem('flappyAchievementsProgress', JSON.stringify(saveData.achievementsProgress));
            localStorage.setItem('flappyLoginStreak', saveData.loginStreak);
            localStorage.setItem('flappyLastLoginDate', saveData.lastLoginDate);
            localStorage.setItem('flappyDailyRewardsClaimed', JSON.stringify(saveData.dailyRewardsClaimed));
            localStorage.setItem('flappyCompletedChallenges', JSON.stringify(saveData.completedChallenges));
            localStorage.setItem('flappyChallengeProgress', JSON.stringify(saveData.challengeProgress));
            localStorage.setItem('flappyLastPlayDate', saveData.lastPlayDate);
            localStorage.setItem('flappyDailyChallenges', JSON.stringify(saveData.dailyChallenges));
            localStorage.setItem('flappyTotalMovingPipes', saveData.totalMovingPipesPassed);
            localStorage.setItem('flappyTotalGamesPlayed', saveData.totalGamesPlayed);
            localStorage.setItem('flappyTotalCoinsCollected', saveData.totalCoinsCollected);
            localStorage.setItem('flappyTotalPipesPassed', saveData.totalPipesPassed);
            localStorage.setItem('flappySecretEffects', JSON.stringify(saveData.secretEffects));
            localStorage.setItem('flappyUpgrades', JSON.stringify(saveData.upgrades));
        }
        
        // ========== UPGRADES SYSTEM ==========
        const upgradesSystem = {
            upgrades: [
                {
                    id: 'coinMultiplier',
                    name: 'Coin Multiplier',
                    description: 'Increase coins earned per pipe',
                    icon: 'üí∞',
                    baseCost: 100, // Reduced from 1000
                    costMultiplier: 1.5, // Reduced from 3.0
                    maxLevel: 50,
                    effectPerLevel: 0.1,
                    getCurrentEffect: function() {
                        const level = saveData.upgrades[this.id];
                        return 1 + (level * this.effectPerLevel);
                    },
                    getNextCost: function() {
                        const level = saveData.upgrades[this.id];
                        if (level >= this.maxLevel) return Infinity;
                        // Progressive scaling: cheaper early, expensive late
                        if (level < 5) {
                            return Math.floor(this.baseCost * Math.pow(1.2, level));
                        } else if (level < 15) {
                            return Math.floor(this.baseCost * Math.pow(1.4, level));
                        } else if (level < 30) {
                            return Math.floor(this.baseCost * Math.pow(1.6, level));
                        } else {
                            return Math.floor(this.baseCost * Math.pow(this.costMultiplier, level));
                        }
                    }
                }
            ],
            
            buyUpgrade(upgradeId) {
                const upgrade = this.upgrades.find(u => u.id === upgradeId);
                if (!upgrade) return false;
                
                const currentLevel = saveData.upgrades[upgradeId];
                if (currentLevel >= upgrade.maxLevel) return false;
                
                const cost = upgrade.getNextCost();
                if (saveData.coins < cost) {
                    messageSystem.addMessage(`Not enough coins! Need ${cost} GU`, 'coin', 2000);
                    return false;
                }
                
                saveData.coins -= cost;
                saveData.upgrades[upgradeId]++;
                totalCoins = saveData.coins;
                
                soundManager.playPurchase();
                messageSystem.addMessage(`${upgrade.name} upgraded to level ${saveData.upgrades[upgradeId]}!`, 'coin', 2000);
                
                saveGame();
                updateCoinDisplays();
                this.renderUpgrades();
                return true;
            },
            
            renderUpgrades() {
                const grid = document.getElementById('upgradeGrid');
                if (!grid) return;
                
                grid.innerHTML = '';
                
                this.upgrades.forEach(upgrade => {
                    const currentLevel = saveData.upgrades[upgrade.id];
                    const nextCost = upgrade.getNextCost();
                    const isMaxed = currentLevel >= upgrade.maxLevel;
                    const currentEffect = upgrade.getCurrentEffect();
                    
                    const card = document.createElement('div');
                    card.className = `upgrade-card ${isMaxed ? 'maxed' : ''}`;
                    
                    const progressPercent = (currentLevel / upgrade.maxLevel) * 100;
                    
                    card.innerHTML = `
                        <div class="upgrade-header">
                            <div class="upgrade-title">${upgrade.icon} ${upgrade.name}</div>
                            <div class="upgrade-level">Lvl ${currentLevel}/${upgrade.maxLevel}</div>
                        </div>
                        <div class="upgrade-description">${upgrade.description}</div>
                        <div class="upgrade-stats">
                            <div>Current: +${Math.round((currentEffect - 1) * 100)}%</div>
                            <div>Next: +${Math.round(upgrade.effectPerLevel * 100)}%</div>
                        </div>
                        <div class="upgrade-cost">
                            ${isMaxed ? 
                                '<span style="color: #4CAF50;">MAX LEVEL</span>' : 
                                `<div class="coin-icon-game" style="width: 20px; height: 20px; font-size: 10px;">GU</div>
                                <span>${nextCost} GU</span>`
                            }
                        </div>
                        ${!isMaxed ? 
                            `<button class="upgrade-btn" onclick="buyUpgrade('${upgrade.id}')" ${saveData.coins < nextCost ? 'disabled' : ''}>
                                ${saveData.coins < nextCost ? 'Need More Coins' : 'UPGRADE'}
                            </button>` :
                            `<button class="upgrade-btn" disabled>MAX LEVEL REACHED</button>`
                        }
                        <div class="upgrade-progress">
                            <div class="upgrade-progress-bar" style="width: ${progressPercent}%"></div>
                        </div>
                    `;
                    
                    grid.appendChild(card);
                });
                
                document.getElementById('upgradeCoins').textContent = saveData.coins + ' GU';
            },
            
            getUpgradeMultiplier(upgradeId) {
                const upgrade = this.upgrades.find(u => u.id === upgradeId);
                if (!upgrade) return 1;
                return upgrade.getCurrentEffect();
            }
        };
        
        function toggleUpgrades() {
            const upgrades = document.getElementById('upgrades');
            const overlay = document.getElementById('menuOverlay');
            const isOpen = upgrades.classList.contains('open');
            
            if (isOpen) {
                upgrades.classList.remove('open');
                overlay.classList.remove('active');
            } else {
                closeAllMenus();
                upgrades.classList.add('open');
                overlay.classList.add('active');
                upgradesSystem.renderUpgrades();
            }
        }
        
        function buyUpgrade(upgradeId) {
            upgradesSystem.buyUpgrade(upgradeId);
        }
        
        // ========== CRATE SHOP SYSTEM ==========
        const crateShop = {
            crates: [
                {
                    id: 'wooden',
                    name: 'Wooden Crate',
                    price: 10,
                    emoji: 'üì¶',
                    color: '#8B4513',
                    rarity: 'common',
                    chances: {
                        common: 70,
                        uncommon: 25,
                        rare: 5,
                        epic: 0,
                        legendary: 0,
                        ultra: 0,
                        secret: 0
                    }
                },
                {
                    id: 'bronze',
                    name: 'Bronze Crate',
                    price: 50,
                    emoji: 'üì¶',
                    color: '#CD7F32',
                    rarity: 'uncommon',
                    chances: {
                        common: 50,
                        uncommon: 35,
                        rare: 12,
                        epic: 3,
                        legendary: 0,
                        ultra: 0,
                        secret: 0
                    }
                },
                {
                    id: 'silver',
                    name: 'Silver Crate',
                    price: 100,
                    emoji: 'üì¶',
                    color: '#C0C0C0',
                    rarity: 'rare',
                    chances: {
                        common: 30,
                        uncommon: 40,
                        rare: 20,
                        epic: 8,
                        legendary: 2,
                        ultra: 0,
                        secret: 0
                    }
                },
                {
                    id: 'gold',
                    name: 'Golden Crate',
                    price: 500,
                    emoji: 'üì¶',
                    color: '#FFD700',
                    rarity: 'epic',
                    chances: {
                        common: 10,
                        uncommon: 25,
                        rare: 35,
                        epic: 25,
                        legendary: 5,
                        ultra: 0,
                        secret: 0
                    }
                },
                {
                    id: 'diamond',
                    name: 'Diamond Crate',
                    price: 1000,
                    emoji: 'üíé',
                    color: '#B9F2FF',
                    rarity: 'legendary',
                    chances: {
                        common: 0,
                        uncommon: 0,
                        rare: 30,
                        epic: 40,
                        legendary: 25,
                        ultra: 5,
                        secret: 0
                    }
                },
                {
                    id: 'ultra',
                    name: 'Ultra Crate',
                    price: 2500,
                    emoji: '‚ö°',
                    color: '#FF00FF',
                    rarity: 'ultra',
                    chances: {
                        common: 0,
                        uncommon: 0,
                        rare: 0,
                        epic: 30,
                        legendary: 40,
                        ultra: 25,
                        secret: 5
                    }
                }
            ],
            
            // 250+ Bird Skins with different emojis
            birdSkins: [],
            
            // Secret skins with special abilities
            secretSkins: [],
            
            init() {
                this.generateAllSkins();
                this.generateSecretSkins();
            },
            
            generateAllSkins() {
                // Common Skins (50)
                const commonEmojis = ['üê¶', 'üê§', 'üê•', 'ü¶Ü', 'ü¶¢', 'ü¶É', 'üêî', 'üêì', 'ü¶ú', 'ü¶ö', 
                                     'ü¶©', 'ü¶â', 'ü¶Ö', 'ü¶Ü', 'ü¶¢', 'ü¶É', 'üêß', 'üê¶‚Äç‚¨õ', 'üê¶‚Äçüî•', 'üê¶‚Äç‚ùÑÔ∏è',
                                     'ü¶ú', 'ü¶ö', 'ü¶©', 'ü¶â', 'ü¶Ö', 'ü¶Ü', 'ü¶¢', 'ü¶É', 'üêß', 'üê¶‚Äç‚¨õ',
                                     'üêî', 'üêì', 'ü¶É', 'ü¶ö', 'ü¶ú', 'ü¶¢', 'ü¶Ü', 'ü¶Ö', 'ü¶â', 'üêß',
                                     'üê•', 'üê§', 'üê¶', 'ü¶©', 'üê¶‚Äçüî•', 'üê¶‚Äç‚ùÑÔ∏è', 'ü¶É', 'ü¶ö', 'ü¶ú', 'ü¶¢'];
                
                this.birdSkins = commonEmojis.map((emoji, index) => ({
                    id: `common_${index}`,
                    name: this.generateBirdName(emoji),
                    emoji: emoji,
                    color: this.getRandomColor(),
                    rarity: 'common',
                    sellPrice: 5 + Math.floor(Math.random() * 10)
                }));
                
                // Uncommon Skins (60)
                const uncommonEmojis = ['ü¶ú', 'ü¶ö', 'ü¶©', 'ü¶â', 'ü¶Ö', 'ü¶Ü', 'ü¶¢', 'ü¶É', 'üêß', 'üê¶‚Äç‚¨õ',
                                       'ü¶á', 'ü¶ã', 'üêù', 'üêû', 'ü¶ó', 'üï∑Ô∏è', 'üï∏Ô∏è', 'üê¢', 'üêç', 'ü¶é',
                                       'üêä', 'ü¶ñ', 'ü¶ï', 'üê≥', 'üêã', 'üê¨', 'ü¶≠', 'üêü', 'üê†', 'üê°',
                                       'ü¶à', 'üêô', 'ü¶ë', 'ü¶ê', 'ü¶û', 'ü¶Ä', 'üêö', 'üêå', 'ü¶ã', 'üêõ',
                                       'üêú', 'üêù', 'üêû', 'ü¶ó', 'ü¶Ç', 'ü¶ü', 'ü¶†', 'üêæ', 'ü¶î', 'üêøÔ∏è',
                                       'ü¶´', 'ü¶°', 'üêá', 'üêÅ', 'üêÄ', 'üêπ', 'üê∞', 'ü¶ä', 'üêª', 'üêº'];
                
                uncommonEmojis.forEach((emoji, index) => {
                    this.birdSkins.push({
                        id: `uncommon_${index}`,
                        name: this.generateBirdName(emoji),
                        emoji: emoji,
                        color: this.getRandomColor(),
                        rarity: 'uncommon',
                        sellPrice: 20 + Math.floor(Math.random() * 30)
                    });
                });
                
                // Rare Skins (50)
                const rareEmojis = ['ü¶Ö', 'ü¶â', 'ü¶Ü', 'ü¶¢', 'ü¶É', 'üêß', 'ü¶á', 'ü¶ã', 'üêù', 'üêû',
                                   'ü¶Ñ', 'üê≤', 'üêâ', 'ü¶ñ', 'ü¶ï', 'ü¶Å', 'üêØ', 'üêÖ', 'üêÜ', 'ü¶ì',
                                   'ü¶ç', 'ü¶ß', 'ü¶£', 'üêò', 'ü¶õ', 'ü¶è', 'üê™', 'üê´', 'ü¶í', 'ü¶ò',
                                   'üêÉ', 'üêÇ', 'üêÑ', 'üêé', 'üêñ', 'üêë', 'üêê', 'üêï', 'üê©', 'ü¶Æ',
                                   'üêï‚Äçü¶∫', 'üêà', 'üêà‚Äç‚¨õ', 'ü¶§', 'ü¶≠', 'ü¶ß', 'ü¶£', 'ü¶õ', 'ü¶è', 'ü¶í'];
                
                rareEmojis.forEach((emoji, index) => {
                    this.birdSkins.push({
                        id: `rare_${index}`,
                        name: this.generateBirdName(emoji),
                        emoji: emoji,
                        color: this.getRandomColor(),
                        rarity: 'rare',
                        sellPrice: 50 + Math.floor(Math.random() * 50)
                    });
                });
                
                // Epic Skins (40)
                const epicEmojis = ['ü¶Ñ', 'üê≤', 'üêâ', 'ü¶ñ', 'ü¶ï', 'ü¶Å', 'üêØ', 'üêÖ', 'üêÜ', 'ü¶ì',
                                   'ü¶ç', 'ü¶ß', 'ü¶£', 'üêò', 'ü¶õ', 'ü¶è', 'ü¶Ñ', 'üê≤', 'üêâ', 'ü¶ñ',
                                   'ü¶ï', 'ü¶Å', 'üêØ', 'üêÖ', 'üêÜ', 'ü¶ì', 'ü¶ç', 'ü¶ß', 'ü¶£', 'üêò',
                                   'ü¶õ', 'ü¶è', 'ü¶Ñ', 'üê≤', 'üêâ', 'ü¶ñ', 'ü¶ï', 'ü¶Å', 'üêØ', 'üêÖ'];
                
                epicEmojis.forEach((emoji, index) => {
                    this.birdSkins.push({
                        id: `epic_${index}`,
                        name: this.generateBirdName(emoji),
                        emoji: emoji,
                        color: this.getRandomColor(),
                        rarity: 'epic',
                        sellPrice: 100 + Math.floor(Math.random() * 100)
                    });
                });
                
                // Legendary Skins (30)
                const legendaryEmojis = ['üëë', 'üèÜ', 'üéñÔ∏è', 'üèÖ', 'ü•á', 'ü•à', 'ü•â', 'üíé', 'üîÆ', 'üéÅ',
                                        'üéä', 'üéâ', '‚ú®', 'üåü', '‚≠ê', 'üå†', '‚òÑÔ∏è', 'üí´', 'ü™ê', 'üåô',
                                        '‚òÄÔ∏è', 'üå§Ô∏è', '‚õÖ', 'üå•Ô∏è', 'üå¶Ô∏è', 'üåßÔ∏è', '‚õàÔ∏è', 'üå©Ô∏è', 'üå®Ô∏è', '‚ùÑÔ∏è'];
                
                legendaryEmojis.forEach((emoji, index) => {
                    this.birdSkins.push({
                        id: `legendary_${index}`,
                        name: this.generateBirdName(emoji),
                        emoji: emoji,
                        color: this.getRandomColor(),
                        rarity: 'legendary',
                        sellPrice: 200 + Math.floor(Math.random() * 300)
                    });
                });
                
                // Ultra Rare Skins (20)
                const ultraEmojis = ['üî•', 'üí•', '‚ö°', 'üí´', '‚ú®', 'üåü', '‚≠ê', 'üå†', '‚òÑÔ∏è', 'ü™ê',
                                   'üåç', 'üåé', 'üåè', 'üõ∏', 'üöÄ', 'üõ∞Ô∏è', 'üëΩ', 'ü§ñ', 'üëæ', 'üéÆ'];
                
                ultraEmojis.forEach((emoji, index) => {
                    this.birdSkins.push({
                        id: `ultra_${index}`,
                        name: this.generateBirdName(emoji),
                        emoji: emoji,
                        color: this.getRandomColor(),
                        rarity: 'ultra',
                        sellPrice: 500 + Math.floor(Math.random() * 500)
                    });
                });
            },
            
            generateSecretSkins() {
                this.secretSkins = [
                    {
                        id: 'secret_golden_goose',
                        name: 'Golden Goose',
                        emoji: 'ü¶¢',
                        color: '#FFD700',
                        rarity: 'secret',
                        sellPrice: 10000,
                        abilities: {
                            coinMultiplier: 10,
                            description: 'Coins x10!'
                        }
                    },
                    {
                        id: 'secret_phoenix',
                        name: 'Phoenix',
                        emoji: 'üî•',
                        color: '#FF4500',
                        rarity: 'secret',
                        sellPrice: 15000,
                        abilities: {
                            invincible: true,
                            description: 'Invincible!'
                        }
                    },
                    {
                        id: 'secret_time_master',
                        name: 'Time Master',
                        emoji: '‚è∞',
                        color: '#00FFFF',
                        rarity: 'secret',
                        sellPrice: 12000,
                        abilities: {
                            pipeSpeed: 0.5,
                            description: 'Slower pipes!'
                        }
                    },
                    {
                        id: 'secret_gravity_defier',
                        name: 'Gravity Defier',
                        emoji: 'ü™ê',
                        color: '#800080',
                        rarity: 'secret',
                        sellPrice: 11000,
                        abilities: {
                            gravity: 0.5,
                            jumpPower: 1.5,
                            description: 'Low gravity!'
                        }
                    },
                    {
                        id: 'secret_score_master',
                        name: 'Score Master',
                        emoji: 'üéØ',
                        color: '#FF0000',
                        rarity: 'secret',
                        sellPrice: 13000,
                        abilities: {
                            scoreMultiplier: 2,
                            description: 'Double score!'
                        }
                    },
                    {
                        id: 'secret_coin_magnet',
                        name: 'Coin Magnet',
                        emoji: 'üß≤',
                        color: '#FFD700',
                        rarity: 'secret',
                        sellPrice: 14000,
                        abilities: {
                            magnet: true,
                            description: 'Coin magnet!'
                        }
                    },
                    {
                        id: 'secret_double_trouble',
                        name: 'Double Trouble',
                        emoji: 'üëØ',
                        color: '#FF69B4',
                        rarity: 'secret',
                        sellPrice: 16000,
                        abilities: {
                            doubleCoins: true,
                            description: 'Double coins!'
                        }
                    },
                    {
                        id: 'secret_rainbow_unicorn',
                        name: 'Rainbow Unicorn',
                        emoji: 'ü¶Ñ',
                        color: 'rainbow',
                        rarity: 'secret',
                        sellPrice: 20000,
                        abilities: {
                            coinMultiplier: 5,
                            scoreMultiplier: 2,
                            description: 'Rainbow powers!'
                        }
                    },
                    {
                        id: 'secret_black_hole',
                        name: 'Black Hole',
                        emoji: '‚ö´',
                        color: '#000000',
                        rarity: 'secret',
                        sellPrice: 18000,
                        abilities: {
                            gravity: 0.3,
                            pipeSpeed: 0.7,
                            description: 'Gravity well!'
                        }
                    },
                    {
                        id: 'secret_god_mode',
                        name: 'GOD MODE',
                        emoji: 'üëë',
                        color: '#FFD700',
                        rarity: 'secret',
                        sellPrice: 50000,
                        abilities: {
                            coinMultiplier: 100,
                            scoreMultiplier: 5,
                            invincible: true,
                            magnet: true,
                            description: 'GOD MODE!'
                        }
                    }
                ];
            },
            
            generateBirdName(emoji) {
                const prefixes = ['Flappy', 'Sky', 'Air', 'Wind', 'Cloud', 'Storm', 'Rain', 'Sun', 'Moon', 'Star',
                                'Golden', 'Silver', 'Bronze', 'Crystal', 'Diamond', 'Ruby', 'Emerald', 'Sapphire',
                                'Ancient', 'Mystic', 'Magic', 'Legendary', 'Epic', 'Rare', 'Common', 'Shiny'];
                const suffixes = ['Bird', 'Wing', 'Feather', 'Beak', 'Tail', 'Flyer', 'Glider', 'Soarer', 'Diver',
                                'Hunter', 'Watcher', 'Keeper', 'Guardian', 'Protector', 'Warrior', 'Mage', 'Knight'];
                
                const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
                const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];
                return `${prefix} ${suffix} ${emoji}`;
            },
            
            getRandomColor() {
                const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF',
                               '#FFA500', '#800080', '#008000', '#000080', '#800000', '#808000',
                               '#008080', '#808080', '#A52A2A', '#FFC0CB', '#FFD700', '#C0C0C0'];
                return colors[Math.floor(Math.random() * colors.length)];
            },
            
            getAllSkins() {
                return [...this.birdSkins, ...this.secretSkins];
            },
            
            getSkinById(id) {
                const allSkins = this.getAllSkins();
                return allSkins.find(skin => skin.id === id) || allSkins[0];
            },
            
            renderShop() {
                const crateGrid = document.getElementById('crateGrid');
                crateGrid.innerHTML = '';
                
                this.crates.forEach(crate => {
                    const card = document.createElement('div');
                    card.className = 'crate-card';
                    card.style.borderColor = crate.color;
                    card.onclick = () => this.buyCrate(crate);
                    
                    const chanceText = this.getChanceText(crate);
                    
                    card.innerHTML = `
                        <div class="crate-icon" style="color: ${crate.color}">${crate.emoji}</div>
                        <div class="crate-name">${crate.name}</div>
                        <div class="crate-price">
                            <div class="coin-icon-game" style="width: 20px; height: 20px; font-size: 10px;">GU</div>
                            <span>${crate.price} GU</span>
                        </div>
                        <div class="crate-chance">${chanceText}</div>
                    `;
                    
                    crateGrid.appendChild(card);
                });
                
                updateCoinDisplays();
            },
            
            getChanceText(crate) {
                const chances = crate.chances;
                const parts = [];
                
                if (chances.common > 0) parts.push(`Common: ${chances.common}%`);
                if (chances.uncommon > 0) parts.push(`Uncommon: ${chances.uncommon}%`);
                if (chances.rare > 0) parts.push(`Rare: ${chances.rare}%`);
                if (chances.epic > 0) parts.push(`Epic: ${chances.epic}%`);
                if (chances.legendary > 0) parts.push(`Legendary: ${chances.legendary}%`);
                if (chances.ultra > 0) parts.push(`Ultra: ${chances.ultra}%`);
                if (chances.secret > 0) parts.push(`Secret: ${chances.secret}%`);
                
                return parts.join(' ‚Ä¢ ');
            },
            
            buyCrate(crate) {
                if (saveData.coins < crate.price) {
                    messageSystem.addMessage(`Not enough coins! Need ${crate.price} GU`, 'coin', 2000);
                    return;
                }
                
                saveData.coins -= crate.price;
                totalCoins = saveData.coins;
                soundManager.playPurchase();
                
                this.openCrate(crate);
                saveGame();
                updateCoinDisplays();
            },
            
            openCrate(crate) {
                const crateOpening = document.getElementById('crateOpening');
                const crateDisplay = document.getElementById('crateDisplay');
                const rollDisplay = document.getElementById('rollDisplay');
                const resultDisplay = document.getElementById('resultDisplay');
                
                crateDisplay.textContent = crate.emoji;
                crateDisplay.style.color = crate.color;
                crateOpening.classList.add('active');
                
                rollDisplay.textContent = 'Opening crate...';
                resultDisplay.textContent = '';
                
                soundManager.playCrateOpen();
                
                setTimeout(() => {
                    rollDisplay.textContent = 'Rolling...';
                    
                    let rollCount = 0;
                    const rollInterval = setInterval(() => {
                        const randomSkin = this.getAllSkins()[Math.floor(Math.random() * this.getAllSkins().length)];
                        resultDisplay.textContent = `${randomSkin.emoji} ${randomSkin.name}`;
                        rollCount++;
                        
                        if (rollCount > 10) {
                            clearInterval(rollInterval);
                            this.revealSkin(crate);
                        }
                    }, 100);
                }, 1000);
            },
            
            revealSkin(crate) {
                const rollDisplay = document.getElementById('rollDisplay');
                const resultDisplay = document.getElementById('resultDisplay');
                
                const skin = this.getRandomSkin(crate);
                
                const alreadyOwned = saveData.ownedSkins.includes(skin.id);
                
                if (!alreadyOwned) {
                    saveData.ownedSkins.push(skin.id);
                    // Play pet unlock sound when getting a new skin
                    soundManager.playPetUnlock();
                }
                
                rollDisplay.textContent = `You got:`;
                
                const rarityColor = this.getRarityColor(skin.rarity);
                let rewardText = '';
                
                if (alreadyOwned) {
                    const refund = Math.floor(skin.sellPrice * 0.5);
                    saveData.coins += refund;
                    totalCoins = saveData.coins;
                    rewardText = `<span style="color: #FFD700; font-size: 24px;">Already owned! +${refund} GU</span>`;
                } else {
                    rewardText = '<span style="color: #4CAF50; font-size: 24px;">NEW SKIN!</span>';
                    
                    if (skin.rarity === 'secret') {
                        soundManager.playSecret();
                        particleSystem.createSecretEffect(skin.emoji, 50);
                        secretEffect.classList.add('active');
                        setTimeout(() => secretEffect.classList.remove('active'), 2000);
                        messageSystem.addMessage(`üéâ SECRET SKIN UNLOCKED: ${skin.name}!`, 'secret', 5000);
                    }
                    
                    const gameStats = {
                        skinsUnlocked: saveData.ownedSkins.length
                    };
                    achievementsSystem.checkAchievements(gameStats);
                }
                
                resultDisplay.innerHTML = `
                    ${skin.emoji} ${skin.name}<br>
                    <span style="font-size: 24px; color: ${rarityColor}">${skin.rarity.toUpperCase()}</span><br>
                    ${rewardText}
                `;
                
                if (skin.rarity === 'secret') {
                    soundManager.playAchievement();
                }
                
                saveGame();
            },
            
            getRandomSkin(crate) {
                const random = Math.random() * 100;
                const chances = crate.chances;
                
                let rarity;
                if (random < chances.common) rarity = 'common';
                else if (random < chances.common + chances.uncommon) rarity = 'uncommon';
                else if (random < chances.common + chances.uncommon + chances.rare) rarity = 'rare';
                else if (random < chances.common + chances.uncommon + chances.rare + chances.epic) rarity = 'epic';
                else if (random < chances.common + chances.uncommon + chances.rare + chances.epic + chances.legendary) rarity = 'legendary';
                else if (random < chances.common + chances.uncommon + chances.rare + chances.epic + chances.legendary + chances.ultra) rarity = 'ultra';
                else rarity = 'secret';
                
                let availableSkins = [];
                
                if (rarity === 'secret') {
                    availableSkins = this.secretSkins;
                } else {
                    availableSkins = this.birdSkins.filter(skin => skin.rarity === rarity);
                }
                
                if (availableSkins.length === 0) {
                    return this.birdSkins[0];
                }
                
                return availableSkins[Math.floor(Math.random() * availableSkins.length)];
            },
            
            getRarityColor(rarity) {
                const colors = {
                    common: '#FFFFFF',
                    uncommon: '#4CAF50',
                    rare: '#2196F3',
                    epic: '#9C27B0',
                    legendary: '#FFD700',
                    ultra: '#FF00FF',
                    secret: '#FF0000'
                };
                return colors[rarity] || '#FFFFFF';
            },
            
            getRarityBorder(rarity) {
                return this.getRarityColor(rarity);
            }
        };
        
        crateShop.init();
        
        function closeCrateOpening() {
            document.getElementById('crateOpening').classList.remove('active');
            crateShop.renderShop();
            renderInventory();
            renderIndex();
        }
        
        // ========== SKIN INDEX SYSTEM ==========
        const skinIndex = {
            currentFilter: 'all',
            searchQuery: '',
            
            renderIndex() {
                const indexGrid = document.getElementById('indexGrid');
                indexGrid.innerHTML = '';
                
                const allSkins = crateShop.getAllSkins();
                let filteredSkins = [...allSkins];
                
                // Apply filter
                if (this.currentFilter === 'owned') {
                    filteredSkins = filteredSkins.filter(skin => saveData.ownedSkins.includes(skin.id));
                } else if (this.currentFilter === 'missing') {
                    filteredSkins = filteredSkins.filter(skin => !saveData.ownedSkins.includes(skin.id));
                } else if (this.currentFilter !== 'all') {
                    filteredSkins = filteredSkins.filter(skin => skin.rarity === this.currentFilter);
                }
                
                // Apply search
                if (this.searchQuery) {
                    const query = this.searchQuery.toLowerCase();
                    filteredSkins = filteredSkins.filter(skin => 
                        skin.name.toLowerCase().includes(query) || 
                        skin.emoji.includes(query) ||
                        skin.rarity.toLowerCase().includes(query)
                    );
                }
                
                filteredSkins.sort((a, b) => {
                    const rarityOrder = { common: 0, uncommon: 1, rare: 2, epic: 3, legendary: 4, ultra: 5, secret: 6 };
                    return rarityOrder[b.rarity] - rarityOrder[a.rarity];
                });
                
                filteredSkins.forEach(skin => {
                    const isOwned = saveData.ownedSkins.includes(skin.id);
                    const isSecret = skin.rarity === 'secret';
                    
                    const card = document.createElement('div');
                    card.className = `index-card ${isOwned ? 'owned' : ''} ${isSecret ? 'secret' : ''}`;
                    card.style.borderColor = crateShop.getRarityColor(skin.rarity);
                    
                    card.innerHTML = `
                        <div class="index-emoji">${skin.emoji}</div>
                        <div class="index-name">${skin.name}</div>
                        <div class="index-rarity" style="color: ${crateShop.getRarityColor(skin.rarity)}">
                            ${skin.rarity.toUpperCase()}
                        </div>
                        <div class="index-stats">
                            ${isOwned ? '‚úì OWNED' : '‚úó MISSING'} ‚Ä¢ Sell: ${skin.sellPrice} GU
                        </div>
                    `;
                    
                    indexGrid.appendChild(card);
                });
                
                document.getElementById('indexOwnedCount').textContent = saveData.ownedSkins.length;
                document.getElementById('indexTotalCount').textContent = allSkins.length;
                document.getElementById('totalSkinsCount').textContent = allSkins.length;
            },
            
            filterIndex(filter) {
                this.currentFilter = filter;
                
                const filterBtns = document.querySelectorAll('.filter-btn');
                filterBtns.forEach(btn => btn.classList.remove('active'));
                
                event.target.classList.add('active');
                this.renderIndex();
            },
            
            searchSkins() {
                this.searchQuery = document.getElementById('skinSearch').value;
                this.renderIndex();
            }
        };
        
        function filterIndex(filter) {
            skinIndex.filterIndex(filter);
        }
        
        function searchSkins() {
            skinIndex.searchSkins();
        }
        
        // ========== INVENTORY SYSTEM ==========
        const inventorySystem = {
            renderInventory() {
                const inventoryGrid = document.getElementById('inventoryGrid');
                inventoryGrid.innerHTML = '';
                
                const allSkins = crateShop.getAllSkins();
                const ownedSkins = allSkins.filter(skin => saveData.ownedSkins.includes(skin.id));
                
                ownedSkins.sort((a, b) => {
                    const rarityOrder = { common: 0, uncommon: 1, rare: 2, epic: 3, legendary: 4, ultra: 5, secret: 6 };
                    return rarityOrder[b.rarity] - rarityOrder[a.rarity];
                });
                
                ownedSkins.forEach(skin => {
                    const isEquipped = saveData.currentSkin === skin.id;
                    const isSecret = skin.rarity === 'secret';
                    
                    const card = document.createElement('div');
                    card.className = `skin-card ${isEquipped ? 'equipped' : ''} ${isSecret ? 'secret' : ''}`;
                    card.style.borderColor = crateShop.getRarityColor(skin.rarity);
                    
                    card.innerHTML = `
                        <div class="skin-emoji">${skin.emoji}</div>
                        <div class="skin-name">${skin.name}</div>
                        <div style="color: ${crateShop.getRarityColor(skin.rarity)}; font-size: 12px; margin-bottom: 5px;">
                            ${skin.rarity.toUpperCase()}
                        </div>
                        <div class="sell-price">Sell: ${skin.sellPrice} GU</div>
                        <div class="skin-actions">
                            ${!isEquipped ? 
                                `<button class="skin-action-btn equip-btn" onclick="equipSkin('${skin.id}')">EQUIP</button>` : 
                                `<button class="skin-action-btn equip-btn" style="background: #666;">EQUIPPED</button>`}
                            <button class="skin-action-btn sell-btn" onclick="sellSkin('${skin.id}')">SELL</button>
                        </div>
                    `;
                    
                    inventoryGrid.appendChild(card);
                });
                
                document.getElementById('ownedSkinsCount').textContent = ownedSkins.length;
                updateCoinDisplays();
            },
            
            equipSkin(skinId) {
                const skin = crateShop.getSkinById(skinId);
                saveData.currentSkin = skinId;
                saveGame();
                
                // Apply secret abilities if equipped skin is a secret
                if (skin.rarity === 'secret') {
                    gameModifiers.updateFromSecret(skin);
                    gameModifiers.showAbility(skin);
                    
                    if (skin.abilities) {
                        saveData.secretEffects[skinId] = true;
                    }
                } else {
                    gameModifiers.reset();
                }
                
                messageSystem.addMessage(`Equipped ${skin.name}`, 'normal', 2000);
                this.renderInventory();
            },
            
            sellSkin(skinId) {
                if (saveData.currentSkin === skinId) {
                    messageSystem.addMessage(`Cannot sell equipped skin!`, 'normal', 2000);
                    return;
                }
                
                if (skinId === 'common_0') {
                    messageSystem.addMessage(`Cannot sell the starting skin!`, 'normal', 2000);
                    return;
                }
                
                const skin = crateShop.getSkinById(skinId);
                const sellPrice = skin.sellPrice;
                
                const index = saveData.ownedSkins.indexOf(skinId);
                if (index > -1) {
                    saveData.ownedSkins.splice(index, 1);
                }
                
                saveData.coins += sellPrice;
                totalCoins = saveData.coins;
                
                messageSystem.addMessage(`Sold ${skin.name} for ${sellPrice} GU`, 'coin', 2000);
                soundManager.playCoin();
                
                saveGame();
                this.renderInventory();
                skinIndex.renderIndex();
            }
        };
        
        function equipSkin(skinId) {
            inventorySystem.equipSkin(skinId);
        }
        
        function sellSkin(skinId) {
            inventorySystem.sellSkin(skinId);
        }
        
        function renderInventory() {
            inventorySystem.renderInventory();
            document.getElementById('inventoryCoins').textContent = saveData.coins + ' GU';
        }
        
        function renderIndex() {
            skinIndex.renderIndex();
        }
        
        // ========== DAILY CHALLENGES SYSTEM ==========
        const dailyChallenges = {
            currentChallenges: null,
            
            generateDailyChallenges() {
                const today = new Date().toDateString();
                
                // Only generate new challenges if it's a new day
                if (saveData.lastPlayDate !== today || !saveData.dailyChallenges) {
                    saveData.lastPlayDate = today;
                    
                    const challengeTypes = [
                        {
                            id: 'score_10',
                            title: 'Score 10 Points',
                            description: 'Get a score of 10 in one run',
                            icon: 'üéØ',
                            reward: 50,
                            type: 'score',
                            target: 10
                        },
                        {
                            id: 'collect_20_coins',
                            title: 'Collect 20 Coins',
                            description: 'Collect 20 coins in total today',
                            icon: 'üí∞',
                            reward: 75,
                            type: 'coins',
                            target: 20
                        },
                        {
                            id: 'play_5_games',
                            title: 'Play 5 Games',
                            description: 'Play 5 games today',
                            icon: 'üéÆ',
                            reward: 100,
                            type: 'games',
                            target: 5
                        },
                        {
                            id: 'survive_30_seconds',
                            title: 'Survive 30 Seconds',
                            description: 'Survive for 30 seconds in one game',
                            icon: '‚è±Ô∏è',
                            reward: 125,
                            type: 'time',
                            target: 30
                        },
                        {
                            id: 'pass_10_moving_pipes',
                            title: 'Pass 10 Moving Pipes',
                            description: 'Successfully pass 10 moving pipes today',
                            icon: 'üîÑ',
                            reward: 150,
                            type: 'moving_pipes',
                            target: 10
                        },
                        {
                            id: 'score_25',
                            title: 'Score 25 Points',
                            description: 'Get a score of 25 in one run',
                            icon: 'üåü',
                            reward: 200,
                            type: 'score',
                            target: 25
                        },
                        {
                            id: 'no_death_15',
                            title: '15 Pipes No Death',
                            description: 'Pass 15 pipes without dying',
                            icon: 'üíÄ',
                            reward: 250,
                            type: 'streak',
                            target: 15
                        },
                        {
                            id: 'open_3_crates',
                            title: 'Open 3 Crates',
                            description: 'Open 3 crates today',
                            icon: 'üì¶',
                            reward: 300,
                            type: 'crates',
                            target: 3
                        }
                    ];
                    
                    const shuffled = [...challengeTypes].sort(() => 0.5 - Math.random());
                    saveData.dailyChallenges = shuffled.slice(0, 4);
                    
                    saveData.challengeProgress = {};
                    saveData.completedChallenges = {};
                    
                    saveGame();
                }
                
                this.currentChallenges = saveData.dailyChallenges;
                return this.currentChallenges;
            },
            
            updateChallengeProgress(challengeId, progress) {
                if (!saveData.challengeProgress[challengeId]) {
                    saveData.challengeProgress[challengeId] = 0;
                }
                
                if (challengeId === 'pass_10_moving_pipes') {
                    if (!saveData.challengeProgress.movingPipesToday) {
                        saveData.challengeProgress.movingPipesToday = 0;
                    }
                    saveData.challengeProgress.movingPipesToday = progress;
                    saveData.challengeProgress[challengeId] = progress;
                } else if (challengeId === 'collect_20_coins') {
                    if (!saveData.challengeProgress.coinsToday) {
                        saveData.challengeProgress.coinsToday = 0;
                    }
                    saveData.challengeProgress.coinsToday = progress;
                    saveData.challengeProgress[challengeId] = progress;
                } else if (challengeId === 'play_5_games') {
                    if (!saveData.challengeProgress.gamesToday) {
                        saveData.challengeProgress.gamesToday = 0;
                    }
                    saveData.challengeProgress.gamesToday = progress;
                    saveData.challengeProgress[challengeId] = progress;
                } else if (challengeId === 'open_3_crates') {
                    if (!saveData.challengeProgress.cratesToday) {
                        saveData.challengeProgress.cratesToday = 0;
                    }
                    saveData.challengeProgress.cratesToday = progress;
                    saveData.challengeProgress[challengeId] = progress;
                } else {
                    saveData.challengeProgress[challengeId] = Math.max(saveData.challengeProgress[challengeId], progress);
                }
                
                const challenge = this.currentChallenges?.find(c => c.id === challengeId);
                if (challenge && saveData.challengeProgress[challengeId] >= challenge.target) {
                    this.completeChallenge(challengeId);
                }
                
                saveGame();
            },
            
            completeChallenge(challengeId) {
                if (saveData.completedChallenges[challengeId]) return;
                
                const challenge = this.currentChallenges?.find(c => c.id === challengeId);
                if (challenge) {
                    saveData.completedChallenges[challengeId] = true;
                    saveData.coins += challenge.reward;
                    totalCoins = saveData.coins;
                    
                    soundManager.playAchievement();
                    messageSystem.addMessage(`üéØ Daily Challenge: ${challenge.title}! +${challenge.reward} GU`, 'coin', 3000);
                    
                    saveGame();
                    updateCoinDisplays();
                    this.renderChallenges();
                }
            },
            
            getTimeUntilReset() {
                const now = new Date();
                const tomorrow = new Date(now);
                tomorrow.setDate(tomorrow.getDate() + 1);
                tomorrow.setHours(0, 0, 0, 0);
                
                const diff = tomorrow - now;
                const hours = Math.floor(diff / (1000 * 60 * 60));
                const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                
                return `${hours.toString().padStart(2, '0')}h ${minutes.toString().padStart(2, '0')}m`;
            },
            
            renderChallenges() {
                const grid = document.getElementById('challengeGrid');
                if (!grid) return;
                
                const challenges = this.generateDailyChallenges();
                grid.innerHTML = '';
                
                challenges.forEach(challenge => {
                    const card = document.createElement('div');
                    card.className = `challenge-card ${saveData.completedChallenges[challenge.id] ? 'completed' : ''}`;
                    
                    let progress = saveData.challengeProgress[challenge.id] || 0;
                    
                    if (challenge.id === 'pass_10_moving_pipes') {
                        progress = saveData.challengeProgress.movingPipesToday || 0;
                    } else if (challenge.id === 'collect_20_coins') {
                        progress = saveData.challengeProgress.coinsToday || 0;
                    } else if (challenge.id === 'play_5_games') {
                        progress = saveData.challengeProgress.gamesToday || 0;
                    } else if (challenge.id === 'open_3_crates') {
                        progress = saveData.challengeProgress.cratesToday || 0;
                    }
                    
                    const progressPercent = Math.min((progress / challenge.target) * 100, 100);
                    
                    card.innerHTML = `
                        <div class="challenge-title">
                            <div class="challenge-title-content">
                                <div class="challenge-icon">${challenge.icon}</div>
                                <div>${challenge.title}</div>
                            </div>
                            ${saveData.completedChallenges[challenge.id] ? 
                                '<span style="color: #4CAF50;">‚úì COMPLETED</span>' : 
                                ''}
                        </div>
                        <div class="challenge-description">${challenge.description}</div>
                        <div class="challenge-reward">
                            <div class="coin-icon-game" style="width: 20px; height: 20px; font-size: 10px;">GU</div>
                            <span>Reward: ${challenge.reward} GU</span>
                        </div>
                        ${!saveData.completedChallenges[challenge.id] ? `
                            <div class="challenge-progress">
                                <div class="challenge-progress-bar" style="width: ${progressPercent}%"></div>
                            </div>
                            <div class="challenge-progress-text">${progress}/${challenge.target}</div>
                        ` : ''}
                    `;
                    
                    grid.appendChild(card);
                });
                
                // Update timer
                document.getElementById('dailyResetTimer').textContent = `Resets in: ${this.getTimeUntilReset()}`;
                
                // Start timer update
                if (!this.timerInterval) {
                    this.timerInterval = setInterval(() => {
                        document.getElementById('dailyResetTimer').textContent = `Resets in: ${this.getTimeUntilReset()}`;
                    }, 60000);
                }
            }
        };
        
        // ========== ACHIEVEMENTS SYSTEM ==========
        const achievementsSystem = {
            achievements: [],
            currentFilter: 'all',
            searchQuery: '',
            
            init() {
                this.generateAchievements();
            },
            
            generateAchievements() {
                // Generate 250 achievements with much harder requirements
                const achievementTemplates = [
                    { baseName: 'Beginner', baseScore: 10, count: 25 },
                    { baseName: 'Novice', baseScore: 25, count: 25 },
                    { baseName: 'Intermediate', baseScore: 50, count: 25 },
                    { baseName: 'Advanced', baseScore: 100, count: 25 },
                    { baseName: 'Expert', baseScore: 250, count: 25 },
                    { baseName: 'Master', baseScore: 500, count: 25 },
                    { baseName: 'Grand Master', baseScore: 750, count: 25 },
                    { baseName: 'Legend', baseScore: 1000, count: 25 },
                    { baseName: 'Mythic', baseScore: 1500, count: 25 },
                    { baseName: 'Godlike', baseScore: 2000, count: 25 }
                ];
                
                const icons = ['üéØ', 'üèÜ', '‚≠ê', 'üåü', 'üëë', 'üî•', 'üíé', '‚ö°', 'üèÖ', 'üéñÔ∏è'];
                let achievementIndex = 0;
                
                achievementTemplates.forEach((template, templateIndex) => {
                    for (let i = 1; i <= template.count; i++) {
                        const scoreRequirement = template.baseScore * i;
                        const reward = Math.floor(scoreRequirement * 0.5);
                        
                        this.achievements.push({
                            id: `achievement_${achievementIndex}`,
                            name: `${template.baseName} Level ${i}`,
                            description: `Score ${scoreRequirement} points`,
                            icon: icons[templateIndex % icons.length],
                            reward: reward,
                            condition: (stats) => stats.highScore >= scoreRequirement,
                            type: this.getTypeByScore(scoreRequirement)
                        });
                        achievementIndex++;
                    }
                });
            },
            
            getTypeByScore(score) {
                if (score <= 100) return 'beginner';
                if (score <= 500) return 'intermediate';
                if (score <= 1000) return 'advanced';
                if (score <= 2500) return 'expert';
                return 'legendary';
            },
            
            checkAchievements(gameStats) {
                let newAchievements = [];
                
                this.achievements.forEach(achievement => {
                    if (!saveData.achievements[achievement.id] && achievement.condition(gameStats)) {
                        saveData.achievements[achievement.id] = true;
                        saveData.coins += achievement.reward;
                        totalCoins = saveData.coins;
                        
                        newAchievements.push(achievement);
                        
                        soundManager.playAchievement();
                        messageSystem.addMessage(`üèÜ Achievement: ${achievement.name}! +${achievement.reward} GU`, 'achievement', 3000);
                    }
                });
                
                if (newAchievements.length > 0) {
                    saveGame();
                    updateCoinDisplays();
                    this.updateProgress();
                }
                
                return newAchievements;
            },
            
            updateProgress() {
                const completed = Object.keys(saveData.achievements).length;
                const total = this.achievements.length;
                const percent = (completed / total) * 100;
                
                document.getElementById('achievementProgress').textContent = `${completed}/${total}`;
                document.getElementById('achievementProgressBar').style.width = `${percent}%`;
            },
            
            renderAchievements() {
                const grid = document.getElementById('achievementGrid');
                if (!grid) return;
                
                grid.innerHTML = '';
                
                let filteredAchievements = [...this.achievements];
                
                // Apply filter
                if (this.currentFilter === 'completed') {
                    filteredAchievements = filteredAchievements.filter(a => saveData.achievements[a.id]);
                } else if (this.currentFilter === 'uncompleted') {
                    filteredAchievements = filteredAchievements.filter(a => !saveData.achievements[a.id]);
                } else if (this.currentFilter !== 'all') {
                    filteredAchievements = filteredAchievements.filter(a => a.type === this.currentFilter);
                }
                
                // Apply search
                if (this.searchQuery) {
                    const query = this.searchQuery.toLowerCase();
                    filteredAchievements = filteredAchievements.filter(a => 
                        a.name.toLowerCase().includes(query) || 
                        a.description.toLowerCase().includes(query) ||
                        a.type.toLowerCase().includes(query)
                    );
                }
                
                filteredAchievements.sort((a, b) => {
                    const aCompleted = saveData.achievements[a.id];
                    const bCompleted = saveData.achievements[b.id];
                    
                    if (aCompleted && !bCompleted) return -1;
                    if (!aCompleted && bCompleted) return 1;
                    return b.reward - a.reward;
                });
                
                filteredAchievements.forEach(achievement => {
                    const card = document.createElement('div');
                    card.className = `achievement-card ${saveData.achievements[achievement.id] ? 'completed' : ''}`;
                    
                    card.innerHTML = `
                        <div class="achievement-icon">${achievement.icon}</div>
                        <div class="achievement-name">${achievement.name}</div>
                        <div class="achievement-desc">${achievement.description}</div>
                        <div class="achievement-reward">Reward: ${achievement.reward} GU</div>
                        <div style="font-size: 10px; color: #aaa; margin-top: 5px;">
                            ${achievement.type.toUpperCase()}
                        </div>
                    `;
                    
                    grid.appendChild(card);
                });
                
                this.updateProgress();
            },
            
            filterAchievements(filter) {
                this.currentFilter = filter;
                
                const filterBtns = document.querySelectorAll('#achievementFilters .filter-btn');
                filterBtns.forEach(btn => btn.classList.remove('active'));
                
                event.target.classList.add('active');
                this.renderAchievements();
            },
            
            searchAchievements() {
                this.searchQuery = document.getElementById('achievementSearch').value;
                this.renderAchievements();
            }
        };
        
        achievementsSystem.init();
        
        function filterAchievements(filter) {
            achievementsSystem.filterAchievements(filter);
        }
        
        function searchAchievements() {
            achievementsSystem.searchAchievements();
        }
        
        // ========== GAME VARIABLES ==========
        let bird = {
            x: canvas.width * 0.15,
            y: canvas.height / 2,
            width: 40,
            height: 28,
            velocity: 0,
            gravity: 0.5,
            jump: -9,
            rotation: 0,
            horizontalMotion: 0
        };
        
        let pipes = [];
        let clouds = [];
        let score = 0;
        let coinsThisRound = 0;
        let totalCoins = saveData.coins;
        let gameStarted = false;
        let gameOver = false;
        let frame = 0;
        let groundX = 0;
        let gameActive = false;
        
        let difficulty = 1;
        let gamesPlayedToday = 0;
        let gameStartTime = 0;
        let totalPipesPassed = saveData.totalPipesPassed;
        let movingPipesPassedToday = 0;
        let currentStreak = 0;
        let bestStreakToday = 0;
        let cratesOpenedToday = 0;
        
        // PIPE CONFIGURATION - CONSTANT DISTANCE
        let PIPE_WIDTH = canvas.width * 0.08;
        let PIPE_GAP = canvas.height * 0.38;
        let BASE_PIPE_SPEED = canvas.width * 0.003;
        let GROUND_HEIGHT = canvas.height * 0.15;
        let BASE_PIPE_DISTANCE = canvas.width * 0.6;
        
        // Coin reward milestones - REDUCED REWARDS
        const coinMilestones = [
            { score: 25, coins: 2, message: "+2 GU!" },
            { score: 50, coins: 5, message: "+5 GU!" },
            { score: 100, coins: 10, message: "+10 GU!" },
            { score: 250, coins: 20, message: "+20 GU!" },
            { score: 500, coins: 50, message: "+50 GU!" }
        ];
        let reachedMilestones = new Set();
        
        // Initialize clouds
        for (let i = 0; i < 6; i++) {
            clouds.push({
                x: Math.random() * canvas.width,
                y: Math.random() * (canvas.height * 0.4),
                width: 60 + Math.random() * 40,
                speed: 0.3 + Math.random() * 0.5
            });
        }
        
        function drawPipe(pipe) {
            // Original Flappy Bird pipe colors
            ctx.fillStyle = pipe.moving ? '#9932CC' : '#228B22';
            
            // Top pipe
            ctx.fillRect(pipe.x, 0, PIPE_WIDTH, pipe.top);
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.strokeRect(pipe.x, 0, PIPE_WIDTH, pipe.top);
            
            // Bottom pipe
            ctx.fillRect(pipe.x, pipe.bottom, PIPE_WIDTH, canvas.height - pipe.bottom);
            ctx.strokeRect(pipe.x, pipe.bottom, PIPE_WIDTH, canvas.height - pipe.bottom);
            
            // Pipe caps (darker shade)
            ctx.fillStyle = pipe.moving ? '#8A2BE2' : '#1A6B1A';
            ctx.fillRect(pipe.x - 5, pipe.top - 20, PIPE_WIDTH + 10, 20);
            ctx.fillRect(pipe.x - 5, pipe.bottom, PIPE_WIDTH + 10, 20);
            
            // Moving pipe indicator (yellow)
            if (pipe.moving) {
                ctx.fillStyle = '#FFFF00';
                ctx.fillRect(pipe.x + PIPE_WIDTH/2 - 5, pipe.top - 15, 10, 10);
                ctx.fillRect(pipe.x + PIPE_WIDTH/2 - 5, pipe.bottom + 5, 10, 10);
            }
        }
        
        function drawCharacter() {
            if (!gameStarted) return;
            
            ctx.save();
            
            const oscillation = Math.sin(frame * 0.1) * 3;
            const verticalFloat = Math.sin(frame * 0.05) * 2;
            
            ctx.translate(bird.x + bird.width / 2 + oscillation, bird.y + bird.height / 2 + verticalFloat);
            ctx.rotate(bird.rotation * Math.PI / 180);
            
            const skin = crateShop.getSkinById(saveData.currentSkin);
            
            let bodyColor, wingColor;
            
            if (skin.color === 'rainbow') {
                const hue = (frame * 3) % 360;
                bodyColor = `hsl(${hue}, 100%, 50%)`;
                wingColor = `hsl(${(hue + 180) % 360}, 100%, 50%)`;
            } else {
                bodyColor = skin.color;
                wingColor = skin.color;
            }
            
            // Body
            ctx.fillStyle = bodyColor;
            ctx.fillRect(-20, -14, 40, 28);
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.strokeRect(-20, -14, 40, 28);
            
            // Beak
            ctx.fillStyle = '#FF6600';
            ctx.beginPath();
            ctx.moveTo(20, -3);
            ctx.lineTo(32, 0);
            ctx.lineTo(20, 3);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Eye
            ctx.fillStyle = '#fff';
            ctx.fillRect(8, -10, 10, 10);
            ctx.fillStyle = '#000';
            ctx.fillRect(12, -8, 5, 6);
            
            // Wing
            ctx.fillStyle = wingColor;
            ctx.fillRect(-10, 5, 20, 10);
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.strokeRect(-10, 5, 20, 10);
            
            ctx.restore();
        }
        
        function update() {
            if (!gameStarted || !gameActive || gameOver) return;
            
            frame++;
            
            particleSystem.update();
            
            checkCoinMilestones();
            
            updateChallengeProgress();
            
            difficulty = 1 + (Math.floor(score / 5) * 0.15);
            
            const coinMultiplierUpgrade = upgradesSystem.getUpgradeMultiplier('coinMultiplier');
            
            bird.velocity += bird.gravity * gameModifiers.gravity;
            bird.y += bird.velocity;
            
            bird.horizontalMotion = Math.sin(frame * 0.08) * 2;
            
            if (bird.velocity < 0) {
                bird.rotation = Math.max(-25, bird.velocity * 3);
            } else {
                bird.rotation = Math.min(90, bird.velocity * 2);
            }
            
            if (bird.y + bird.height >= canvas.height - GROUND_HEIGHT) {
                if (!gameModifiers.invincible) {
                    triggerDeath();
                } else {
                    bird.y = canvas.height - GROUND_HEIGHT - bird.height;
                    bird.velocity = 0;
                }
                return;
            }
            
            if (bird.y <= 0) {
                bird.y = 0;
                bird.velocity = 0;
            }
            
            // Update pipes - WITH VERTICAL MOVEMENT FOR PURPLE PIPES
            pipes.forEach((pipe) => {
                pipe.x -= BASE_PIPE_SPEED * difficulty * gameModifiers.pipeSpeed;
                
                // FIXED: Vertical movement for purple pipes
                if (pipe.moving) {
                    // Update pipe position based on movement direction
                    pipe.top += pipe.moveSpeed * pipe.moveDirection;
                    pipe.bottom += pipe.moveSpeed * pipe.moveDirection;
                    
                    // Reverse direction if hitting boundaries
                    if (pipe.top <= canvas.height * 0.05 || 
                        pipe.bottom >= canvas.height - GROUND_HEIGHT - 20) {
                        pipe.moveDirection *= -1;
                    }
                }
                
                if (!pipe.scored && pipe.x + PIPE_WIDTH < bird.x) {
                    pipe.scored = true;
                    score += 1 * gameModifiers.scoreMultiplier;
                    coinsThisRound++;
                    
                    // FIXED: HARDER COINS - Only 1-2 coins per pipe without upgrades
                    let coinEarned = Math.floor(Math.random() * 2) + 1; // 1 or 2 coins
                    coinEarned *= gameModifiers.coinMultiplier * coinMultiplierUpgrade;
                    if (gameModifiers.doubleCoins) coinEarned *= 2;
                    
                    totalCoins += Math.floor(coinEarned);
                    totalPipesPassed++;
                    currentStreak++;
                    
                    if (currentStreak > bestStreakToday) {
                        bestStreakToday = currentStreak;
                    }
                    
                    soundManager.playCoin();
                    
                    particleSystem.createCoinSparkles(bird.x, bird.y);
                    
                    if (pipe.moving) {
                        movingPipesPassedToday++;
                        saveData.totalMovingPipesPassed++;
                    }
                    
                    scoreDisplay.textContent = Math.floor(score);
                    document.getElementById('coinCount').textContent = Math.floor(totalCoins);
                }
                
                if (!gameModifiers.invincible && 
                    bird.x + bird.horizontalMotion < pipe.x + PIPE_WIDTH && 
                    bird.x + bird.horizontalMotion + bird.width > pipe.x && 
                    (bird.y < pipe.top || bird.y + bird.height > pipe.bottom)) {
                    triggerDeath();
                    return;
                }
            });
            
            pipes = pipes.filter(pipe => pipe.x > -PIPE_WIDTH);
            
            // FIXED: CONSTANT DISTANCE BETWEEN PIPES
            if (pipes.length === 0 || canvas.width - pipes[pipes.length - 1].x > BASE_PIPE_DISTANCE) {
                createPipe();
            }
        }
        
        function createPipe() {
            const minTop = canvas.height * 0.15;
            const maxTop = canvas.height - GROUND_HEIGHT - PIPE_GAP - 100;
            const top = Math.random() * (maxTop - minTop) + minTop;
            
            const isMoving = Math.random() < 0.4;
            
            // FIXED: Set movement parameters for moving pipes
            let moveDirection = 0;
            let moveSpeed = 0;
            if (isMoving) {
                // Random initial direction: -1 for up, 1 for down
                moveDirection = Math.random() > 0.5 ? 1 : -1;
                // Random speed between 1-3
                moveSpeed = 1 + Math.random() * 2;
            }
            
            pipes.push({
                x: canvas.width,
                top: top,
                bottom: top + PIPE_GAP,
                scored: false,
                moving: isMoving,
                moveDirection: moveDirection, // FIXED: Add movement direction
                moveSpeed: moveSpeed, // FIXED: Add movement speed
                originalTop: top
            });
        }
        
        function checkCoinMilestones() {
            for (const milestone of coinMilestones) {
                if (score >= milestone.score && !reachedMilestones.has(milestone.score)) {
                    reachedMilestones.add(milestone.score);
                    
                    let coinsEarned = milestone.coins;
                    coinsEarned *= gameModifiers.coinMultiplier * upgradesSystem.getUpgradeMultiplier('coinMultiplier');
                    if (gameModifiers.doubleCoins) coinsEarned *= 2;
                    
                    totalCoins += Math.floor(coinsEarned);
                    saveData.coins = totalCoins;
                    
                    soundManager.playCoin();
                    
                    if (milestone.coins >= 20) {
                        messageSystem.addMessage(milestone.message.replace('+', `+${Math.floor(coinsEarned)}`), 'coin', 3000);
                        particleSystem.createCelebration(30);
                    } else {
                        messageSystem.addMessage(milestone.message.replace('+', `+${Math.floor(coinsEarned)}`), 'coin', 2000);
                    }
                    
                    document.getElementById('coinCount').textContent = Math.floor(totalCoins);
                    
                    break;
                }
            }
        }
        
        function updateChallengeProgress() {
            dailyChallenges.updateChallengeProgress('score_10', score);
            dailyChallenges.updateChallengeProgress('score_25', score);
            dailyChallenges.updateChallengeProgress('collect_20_coins', coinsThisRound);
            
            const currentTime = Date.now();
            const secondsPlayed = Math.floor((currentTime - gameStartTime) / 1000);
            dailyChallenges.updateChallengeProgress('survive_30_seconds', secondsPlayed);
            
            dailyChallenges.updateChallengeProgress('pass_10_moving_pipes', movingPipesPassedToday);
            dailyChallenges.updateChallengeProgress('no_death_15', bestStreakToday);
        }
        
        function draw() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#4EC0CA');
            gradient.addColorStop(0.7, '#7DD0D8');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawClouds();
            
            if (gameStarted) {
                pipes.forEach(drawPipe);
                drawCharacter();
            }
            
            drawGround();
            
            particleSystem.draw();
        }
        
        function drawClouds() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            clouds.forEach(cloud => {
                ctx.fillRect(cloud.x, cloud.y, cloud.width, 25);
                ctx.fillRect(cloud.x + 10, cloud.y - 15, cloud.width - 20, 20);
                ctx.fillRect(cloud.x + 20, cloud.y - 25, cloud.width - 40, 20);
                
                cloud.x -= cloud.speed * difficulty;
                if (cloud.x + cloud.width < 0) {
                    cloud.x = canvas.width;
                    cloud.y = Math.random() * (canvas.height * 0.4);
                }
            });
        }
        
        function drawGround() {
            const groundY = canvas.height - GROUND_HEIGHT;
            
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, groundY, canvas.width, GROUND_HEIGHT);
            
            ctx.fillStyle = '#654321';
            for (let x = 0; x < canvas.width; x += 20) {
                for (let y = groundY + 30; y < canvas.height; y += 20) {
                    ctx.fillRect(x + (groundX % 20), y, 10, 10);
                }
            }
            
            ctx.fillStyle = '#7EC850';
            for (let x = -20; x < canvas.width + 20; x += 10) {
                const offsetX = (x + groundX) % canvas.width;
                if (offsetX < 0) continue;
                ctx.fillRect(offsetX, groundY, 10, 5);
            }
            
            ctx.fillStyle = '#5EAA30';
            for (let x = -20; x < canvas.width + 20; x += 15) {
                const offsetX = (x + groundX) % canvas.width;
                if (offsetX < 0) continue;
                ctx.fillRect(offsetX, groundY, 8, 15);
                ctx.fillRect(offsetX + 3, groundY + 15, 8, 15);
            }
            
            ctx.fillStyle = '#9EE86F';
            for (let x = -15; x < canvas.width + 15; x += 15) {
                const offsetX = (x + groundX) % canvas.width;
                if (offsetX < 0) continue;
                ctx.fillRect(offsetX, groundY + 5, 4, 10);
            }
            
            if (gameStarted && gameActive && !gameOver) {
                groundX -= BASE_PIPE_SPEED * difficulty;
                if (groundX <= -canvas.width) groundX = 0;
            }
        }
        
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        function flap() {
            if (!gameStarted) return;
            
            if (!gameActive) {
                return;
            }
            
            if (gameOver) {
                resetGame();
                return;
            }
            
            bird.velocity = bird.jump * gameModifiers.jumpPower;
            soundManager.playJump();
        }
        
        function startWaitTimer() {
            setTimeout(() => {
                gameActive = true;
                gameStartTime = Date.now();
                gamesPlayedToday++;
                saveData.totalGamesPlayed++;
                
                dailyChallenges.updateChallengeProgress('play_5_games', gamesPlayedToday);
                
                saveData.totalCoinsCollected += coinsThisRound;
                
                const gameStats = {
                    gamesPlayed: saveData.totalGamesPlayed,
                    highScore: saveData.highScore,
                    totalCoins: saveData.totalCoinsCollected,
                    totalPipesPassed: totalPipesPassed,
                    movingPipesPassed: saveData.totalMovingPipesPassed,
                    skinsUnlocked: saveData.ownedSkins.length,
                    loginStreak: saveData.loginStreak,
                    completedAchievements: Object.keys(saveData.achievements).length
                };
                achievementsSystem.checkAchievements(gameStats);
            }, 2000);
        }
        
        async function triggerDeath() {
            if (gameOver) return;
            
            gameOver = true;
            soundManager.playDeath();
            
            const fadeOverlay = document.getElementById('fadeOverlay');
            fadeOverlay.classList.add('active');
            
            saveData.coins = totalCoins;
            saveData.totalPipesPassed = totalPipesPassed;
            saveData.totalCoinsCollected += coinsThisRound;
            
            if (score > saveData.highScore) {
                saveData.highScore = score;
                
                if (score >= 50) {
                    messageSystem.addMessage(`üéâ NEW HIGH SCORE: ${score}!`, 'achievement', 3000);
                }
            }
            
            const gameStats = {
                gamesPlayed: saveData.totalGamesPlayed,
                highScore: saveData.highScore,
                totalCoins: saveData.totalCoinsCollected,
                totalPipesPassed: totalPipesPassed,
                movingPipesPassed: saveData.totalMovingPipesPassed,
                skinsUnlocked: saveData.ownedSkins.length,
                loginStreak: saveData.loginStreak,
                completedAchievements: Object.keys(saveData.achievements).length
            };
            achievementsSystem.checkAchievements(gameStats);
            
            saveGame();
            
            setTimeout(() => {
                resetGame();
                startScreen.classList.add('active');
                document.getElementById('score').classList.add('hidden');
                document.getElementById('coins').classList.add('hidden');
                updateCoinDisplays();
                updateLoginDisplay();
                
                setTimeout(() => {
                    fadeOverlay.classList.remove('active');
                }, 100);
            }, 600);
        }
        
        function resetGame() {
            bird.y = canvas.height / 2;
            bird.velocity = 0;
            bird.rotation = 0;
            bird.horizontalMotion = 0;
            pipes = [];
            score = 0;
            coinsThisRound = 0;
            gameStarted = false;
            gameActive = false;
            gameOver = false;
            frame = 0;
            groundX = 0;
            difficulty = 1;
            currentStreak = 0;
            
            reachedMilestones.clear();
            particleSystem.particles = [];
            
            gameModifiers.reset();
            
            scoreDisplay.textContent = '0';
        }
        
        function startGameFromMenu() {
            startScreen.classList.remove('active');
            closeAllMenus();
            
            setTimeout(() => {
                gameStarted = true;
                document.getElementById('score').classList.remove('hidden');
                document.getElementById('coins').classList.remove('hidden');
                document.getElementById('coinCount').textContent = Math.floor(totalCoins);
                pipes = [];
                createPipe();
                startWaitTimer();
            }, 100);
        }
        
        function toggleShop() {
            const shop = document.getElementById('shop');
            const overlay = document.getElementById('menuOverlay');
            const isOpen = shop.classList.contains('open');
            
            if (isOpen) {
                shop.classList.remove('open');
                overlay.classList.remove('active');
            } else {
                closeAllMenus();
                shop.classList.add('open');
                overlay.classList.add('active');
                crateShop.renderShop();
            }
        }
        
        function toggleInventory() {
            const inventory = document.getElementById('inventory');
            const overlay = document.getElementById('menuOverlay');
            const isOpen = inventory.classList.contains('open');
            
            if (isOpen) {
                inventory.classList.remove('open');
                overlay.classList.remove('active');
            } else {
                closeAllMenus();
                inventory.classList.add('open');
                overlay.classList.add('active');
                renderInventory();
            }
        }
        
        function toggleIndex() {
            const index = document.getElementById('index');
            const overlay = document.getElementById('menuOverlay');
            const isOpen = index.classList.contains('open');
            
            if (isOpen) {
                index.classList.remove('open');
                overlay.classList.remove('active');
            } else {
                closeAllMenus();
                index.classList.add('open');
                overlay.classList.add('active');
                renderIndex();
            }
        }
        
        function toggleChallenges() {
            const challenges = document.getElementById('challenges');
            const overlay = document.getElementById('menuOverlay');
            const isOpen = challenges.classList.contains('open');
            
            if (isOpen) {
                challenges.classList.remove('open');
                overlay.classList.remove('active');
            } else {
                closeAllMenus();
                challenges.classList.add('open');
                overlay.classList.add('active');
                dailyChallenges.renderChallenges();
            }
        }
        
        function toggleAchievements() {
            const achievements = document.getElementById('achievements');
            const overlay = document.getElementById('menuOverlay');
            const isOpen = achievements.classList.contains('open');
            
            if (isOpen) {
                achievements.classList.remove('open');
                overlay.classList.remove('active');
            } else {
                closeAllMenus();
                achievements.classList.add('open');
                overlay.classList.add('active');
                achievementsSystem.renderAchievements();
            }
        }
        
        function closeAllMenus() {
            document.getElementById('shop').classList.remove('open');
            document.getElementById('inventory').classList.remove('open');
            document.getElementById('index').classList.remove('open');
            document.getElementById('challenges').classList.remove('open');
            document.getElementById('achievements').classList.remove('open');
            document.getElementById('upgrades').classList.remove('open');
            document.getElementById('menuOverlay').classList.remove('active');
        }
        
        function updateCoinDisplays() {
            document.getElementById('menuCoins').textContent = Math.floor(saveData.coins);
            document.getElementById('menuHighScore').textContent = saveData.highScore;
            document.getElementById('shopCoins').textContent = Math.floor(saveData.coins) + ' GU';
        }
        
        // ========== DAILY LOGIN SYSTEM ==========
        const dailyLoginSystem = {
            rewards: [10, 20, 30, 50, 75, 100, 150, 200, 250, 300, 350, 400, 450, 500],
            
            checkDailyLogin() {
                const today = new Date().toDateString();
                
                if (saveData.lastLoginDate !== today) {
                    const yesterday = new Date();
                    yesterday.setDate(yesterday.getDate() - 1);
                    const yesterdayStr = yesterday.toDateString();
                    
                    if (saveData.lastLoginDate === yesterdayStr) {
                        saveData.loginStreak++;
                    } else if (saveData.lastLoginDate && saveData.lastLoginDate !== today) {
                        saveData.loginStreak = 1;
                    } else if (!saveData.lastLoginDate) {
                        saveData.loginStreak = 1;
                    }
                    
                    saveData.lastLoginDate = today;
                    
                    const hasClaimedToday = saveData.dailyRewardsClaimed.includes(today);
                    if (!hasClaimedToday) {
                        setTimeout(() => {
                            this.showLoginBonus();
                        }, 1000);
                    }
                    
                    saveGame();
                }
                
                updateLoginDisplay();
            },
            
            showLoginBonus() {
                const loginMenu = document.getElementById('dailyLogin');
                if (loginMenu) {
                    document.getElementById('currentStreak').textContent = saveData.loginStreak;
                    
                    const todayIndex = Math.min(saveData.loginStreak - 1, this.rewards.length - 1);
                    const reward = this.rewards[todayIndex];
                    document.getElementById('todaysReward').textContent = reward;
                    
                    this.renderCalendar();
                    
                    loginMenu.style.display = 'block';
                }
            },
            
            claimDailyReward() {
                const today = new Date().toDateString();
                const todayIndex = Math.min(saveData.loginStreak - 1, this.rewards.length - 1);
                const reward = this.rewards[todayIndex];
                
                saveData.coins += reward;
                totalCoins = saveData.coins;
                
                saveData.dailyRewardsClaimed.push(today);
                
                soundManager.playAchievement();
                
                messageSystem.addMessage(`üéÅ Daily Reward: +${reward} GU! Streak: ${saveData.loginStreak} days`, 'coin', 3000);
                
                document.getElementById('dailyLogin').style.display = 'none';
                
                saveGame();
                updateCoinDisplays();
                updateLoginDisplay();
            },
            
            renderCalendar() {
                const calendar = document.getElementById('loginCalendar');
                if (!calendar) return;
                
                calendar.innerHTML = '';
                
                const today = new Date();
                const claimedDates = new Set(saveData.dailyRewardsClaimed);
                
                for (let i = 0; i < 7; i++) {
                    const dayDate = new Date();
                    dayDate.setDate(today.getDate() - (6 - i));
                    const dayStr = dayDate.toDateString();
                    
                    const day = document.createElement('div');
                    day.className = 'login-day';
                    
                    const dayIndex = Math.min(saveData.loginStreak - (6 - i), this.rewards.length - 1);
                    const reward = dayIndex >= 0 ? this.rewards[dayIndex] : this.rewards[0];
                    
                    if (claimedDates.has(dayStr)) {
                        day.classList.add('claimed');
                    }
                    
                    if (i === 6) {
                        day.classList.add('today');
                    }
                    
                    day.innerHTML = `
                        <div>Day ${i + 1}</div>
                        <div class="login-reward">${reward} GU</div>
                    `;
                    
                    calendar.appendChild(day);
                }
            }
        };
        
        function updateLoginDisplay() {
            const today = new Date().toDateString();
            const hasClaimedToday = saveData.dailyRewardsClaimed.includes(today);
            
            if (hasClaimedToday) {
                document.getElementById('dailyLoginInfo').textContent = `üî• ${saveData.loginStreak} Day Streak!`;
            } else {
                document.getElementById('dailyLoginInfo').textContent = 'üéÅ Daily Login Bonus Available!';
            }
        }
        
        function claimDailyReward() {
            dailyLoginSystem.claimDailyReward();
        }
        
        function initGameModifiers() {
            const skin = crateShop.getSkinById(saveData.currentSkin);
            if (skin.rarity === 'secret') {
                gameModifiers.updateFromSecret(skin);
            }
        }
        
        crateShop.originalOpenCrate = crateShop.openCrate;
        crateShop.openCrate = function(crate) {
            cratesOpenedToday++;
            dailyChallenges.updateChallengeProgress('open_3_crates', cratesOpenedToday);
            this.originalOpenCrate(crate);
        };
        
        canvas.addEventListener('click', flap);
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (!gameStarted && startScreen.classList.contains('active')) {
                    startGameFromMenu();
                } else {
                    flap();
                }
            }
        });
        
        initGameModifiers();
        updateCoinDisplays();
        updateLoginDisplay();
        dailyLoginSystem.checkDailyLogin();
        dailyChallenges.generateDailyChallenges();
        gameLoop();
        
        const initialStats = {
            gamesPlayed: saveData.totalGamesPlayed,
            highScore: saveData.highScore,
            totalCoins: saveData.totalCoinsCollected,
            totalPipesPassed: saveData.totalPipesPassed,
            movingPipesPassed: saveData.totalMovingPipesPassed,
            skinsUnlocked: saveData.ownedSkins.length,
            loginStreak: saveData.loginStreak,
            completedAchievements: Object.keys(saveData.achievements).length
        };
        achievementsSystem.checkAchievements(initialStats);
    </script>
</body>
</html>
